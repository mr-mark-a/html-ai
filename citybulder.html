<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metro City Builder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow: hidden;
        }

        .game-container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 250px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            overflow-y: auto;
        }

        .sidebar h1 {
            color: #4CAF50;
            margin-bottom: 20px;
            text-align: center;
            font-size: 24px;
        }

        .stats {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .building-menu {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
        }

        .building-menu h3 {
            color: #FFD700;
            margin-bottom: 15px;
            text-align: center;
        }

        .building-btn {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .building-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        }

        .building-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .building-cost {
            font-size: 12px;
            opacity: 0.8;
        }

        .game-board {
            flex: 1;
            position: relative;
            background: #2c3e50;
            overflow: hidden;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(20, 1fr);
            grid-template-rows: repeat(15, 1fr);
            gap: 2px;
            height: 100%;
            padding: 10px;
        }

        .grid-cell {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }

        .grid-cell:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #4CAF50;
            transform: scale(1.05);
        }

        .grid-cell.occupied {
            cursor: pointer;
        }

        .grid-cell.occupied:hover {
            transform: scale(1.05);
            border-color: #FFD700;
        }

        .grid-cell.demolish-mode:hover {
            border-color: #e74c3c !important;
            background: rgba(231, 76, 60, 0.2) !important;
        }

        .building {
            width: 100%;
            height: 100%;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            animation: buildingAppear 0.5s ease-out;
            position: relative;
        }

        .building-stack {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #FFD700;
            color: #000;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            border: 2px solid white;
        }

        .building-layers {
            position: absolute;
            bottom: 2px;
            left: 2px;
            right: 2px;
            display: flex;
            gap: 1px;
            flex-wrap: wrap;
            max-height: 15px;
            overflow: hidden;
        }

        .layer-indicator {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            border: 1px solid white;
        }

        @keyframes buildingAppear {
            from {
                transform: scale(0) rotate(180deg);
                opacity: 0;
            }
            to {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        .metro-station {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }

        .metro-line {
            background: linear-gradient(45deg, #3498db, #2980b9);
        }

        .metro-depot {
            background: linear-gradient(45deg, #9b59b6, #8e44ad);
        }

        .metro-office {
            background: linear-gradient(45deg, #f39c12, #e67e22);
        }

        .skyscraper {
            background: linear-gradient(45deg, #34495e, #2c3e50);
        }

        .city-office {
            background: linear-gradient(45deg, #16a085, #1abc9c);
        }

        .hotel {
            background: linear-gradient(45deg, #e91e63, #ad1457);
        }

        .apartment {
            background: linear-gradient(45deg, #8e44ad, #9b59b6);
        }

        .column {
            background: linear-gradient(45deg, #95a5a6, #7f8c8d);
        }

        .selected-building {
            background: rgba(76, 175, 80, 0.3);
            border-color: #4CAF50 !important;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 1000;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            border-left: 4px solid #4CAF50;
        }

        .notification.error {
            border-left: 4px solid #f44336;
        }

        .reset-btn {
            width: 100%;
            padding: 12px;
            margin-top: 20px;
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .reset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
        }

        .inventory-button {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 2px solid #4CAF50;
            border-radius: 10px;
            padding: 12px 16px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            transition: all 0.3s ease;
            z-index: 1001;
            backdrop-filter: blur(10px);
        }

        .inventory-button:hover {
            background: rgba(76, 175, 80, 0.2);
            transform: scale(1.05);
        }

        .inventory-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border: 2px solid #4CAF50;
            border-radius: 10px;
            padding: 20px;
            min-width: 250px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1001;
            backdrop-filter: blur(10px);
            transform: translateX(100%);
            opacity: 0;
            transition: all 0.3s ease;
        }

        .inventory-panel.show {
            transform: translateX(0);
            opacity: 1;
        }

        .inventory-panel h3 {
            color: #4CAF50;
            margin-bottom: 15px;
            text-align: center;
            font-size: 18px;
        }

        .inventory-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .inventory-item:last-child {
            border-bottom: none;
        }

        .inventory-building {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .inventory-emoji {
            font-size: 20px;
        }

        .inventory-name {
            font-weight: bold;
        }

        .inventory-count {
            background: #4CAF50;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: bold;
            min-width: 30px;
            text-align: center;
        }

        .inventory-stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        .inventory-stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .close-inventory {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: #f44336;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-inventory:hover {
            color: #ff6b6b;
        }

        .project-button {
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 2px solid #9b59b6;
            border-radius: 10px;
            padding: 12px 16px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            transition: all 0.3s ease;
            z-index: 1001;
            backdrop-filter: blur(10px);
        }

        .project-button:hover {
            background: rgba(155, 89, 182, 0.2);
            transform: scale(1.05);
        }

        .project-panel {
            position: fixed;
            top: 130px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border: 2px solid #9b59b6;
            border-radius: 10px;
            padding: 20px;
            min-width: 300px;
            max-height: 500px;
            overflow-y: auto;
            z-index: 1001;
            backdrop-filter: blur(10px);
            transform: translateX(100%);
            opacity: 0;
            transition: all 0.3s ease;
        }

        .project-panel.show {
            transform: translateX(0);
            opacity: 1;
        }

        .project-panel h3 {
            color: #9b59b6;
            margin-bottom: 15px;
            text-align: center;
            font-size: 18px;
        }

        .project-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .project-item:hover {
            background: rgba(155, 89, 182, 0.2);
            border-color: #9b59b6;
            transform: translateY(-2px);
        }

        .project-item.current {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.2);
        }

        .project-name {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
            color: #FFD700;
        }

        .project-stats {
            font-size: 12px;
            color: #ccc;
            margin-bottom: 5px;
        }

        .project-date {
            font-size: 11px;
            color: #999;
        }

        .project-actions {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }

        .project-action-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s ease;
        }

        .project-action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .project-action-btn.load {
            border-color: #3498db;
            color: #3498db;
        }

        .project-action-btn.delete {
            border-color: #e74c3c;
            color: #e74c3c;
        }

        .project-action-btn.rename {
            border-color: #f39c12;
            color: #f39c12;
        }

        .no-projects {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 20px;
        }

        .close-project-panel {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: #f44336;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-project-panel:hover {
            color: #ff6b6b;
        }

        .train {
            position: absolute;
            font-size: 16px;
            z-index: 10;
            animation: trainMove 8s linear infinite;
            pointer-events: none;
        }

        @keyframes trainMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(100%, 0); }
        }

        .rail-connection {
            position: absolute;
            background: #3498db;
            z-index: 5;
            pointer-events: none;
        }

        .rail-horizontal {
            height: 4px;
            top: 50%;
            transform: translateY(-50%);
        }

        .rail-vertical {
            width: 4px;
            left: 50%;
            transform: translateX(-50%);
        }

        .rail-corner {
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: #3498db;
        }

        /* Station Connection Styles */
        .station-connection {
            position: absolute;
            border: 3px dashed #e74c3c;
            border-radius: 8px;
            background: rgba(231, 76, 60, 0.1);
            z-index: 3;
            pointer-events: none;
            animation: stationPulse 2s infinite;
        }

        @keyframes stationPulse {
            0%, 100% { 
                border-color: #e74c3c;
                background: rgba(231, 76, 60, 0.1);
            }
            50% { 
                border-color: #c0392b;
                background: rgba(231, 76, 60, 0.2);
            }
        }

        .connected-station {
            position: relative;
        }

        .connected-station .building {
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
            border: 2px solid #e74c3c;
        }

        .connection-indicator {
            position: absolute;
            top: -8px;
            right: -8px;
            font-size: 12px;
            background: #e74c3c;
            color: white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            animation: connectionBlink 1.5s infinite;
        }

        @keyframes connectionBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="sidebar">
            <h1>üöá Metro Builder</h1>
            
            <div class="stats">
                <div class="stat-item">
                    <span>üí∞ Money:</span>
                    <span id="money">$1000</span>
                </div>
                <div class="stat-item">
                    <span>üë• Population:</span>
                    <span id="population">0</span>
                </div>
                <div class="stat-item">
                    <span>üè¢ Buildings:</span>
                    <span id="buildings">0</span>
                </div>
                <div class="stat-item">
                    <span>üíµ Income/sec:</span>
                    <span id="income">$0</span>
                </div>
                <div class="stat-item">
                    <span>üöá Network:</span>
                    <span id="network-status">Inactive</span>
                </div>
            </div>

            <div class="building-menu">
                <h3>üèóÔ∏è Build Metro</h3>
                
                <button class="building-btn" id="station-btn" data-building="station">
                    üöâ Metro Station
                    <div class="building-cost">Cost: $100 | Income: $10/s</div>
                </button>
                
                <button class="building-btn" id="line-btn" data-building="line">
                    üõ§Ô∏è Metro Line
                    <div class="building-cost">Cost: $50 | Connects stations</div>
                </button>
                
                <button class="building-btn" id="depot-btn" data-building="depot">
                    üè≠ Metro Depot
                    <div class="building-cost">Cost: $200 | Income: $25/s*</div>
                </button>
                
                <button class="building-btn" id="office-btn" data-building="office">
                    üè¢ Metro Office
                    <div class="building-cost">Cost: $300 | Income: $40/s*</div>
                </button>

                <button class="building-btn" id="column-btn" data-building="column">
                    üèõÔ∏è Column
                    <div class="building-cost">Cost: $75 | Decorative structure</div>
                </button>

                <h3 style="color: #FFD700; margin: 20px 0 15px 0; text-align: center; font-size: 16px;">üèôÔ∏è City Buildings</h3>
                
                <button class="building-btn" id="apartment-btn" data-building="apartment">
                    üè† Apartment
                    <div class="building-cost">Cost: $150 | Income: $20/s</div>
                </button>
                
                <button class="building-btn" id="cityoffice-btn" data-building="cityoffice">
                    üè¨ City Office
                    <div class="building-cost">Cost: $250 | Income: $35/s</div>
                </button>
                
                <button class="building-btn" id="hotel-btn" data-building="hotel">
                    üè® Hotel
                    <div class="building-cost">Cost: $400 | Income: $50/s*</div>
                </button>
                
                <button class="building-btn" id="skyscraper-btn" data-building="skyscraper">
                    üèôÔ∏è Skyscraper
                    <div class="building-cost">Cost: $500 | Income: $60/s*</div>
                </button>

                <h3 style="color: #e74c3c; margin: 20px 0 15px 0; text-align: center; font-size: 16px;">üí• Demolish Store</h3>
                
                <button class="building-btn" id="demolish-btn" data-building="demolish" style="background: linear-gradient(45deg, #e74c3c, #c0392b); margin-top: 5px;">
                    üß® Single Demolish
                    <div class="building-cost">Remove top building (full refund)</div>
                </button>
                
                <button class="building-btn" id="demolish-stack-btn" data-building="demolish-stack" style="background: linear-gradient(45deg, #c0392b, #a93226); margin-top: 5px;">
                    üí• Stack Demolish
                    <div class="building-cost">Remove entire building stack</div>
                </button>
                
                <button class="building-btn" id="demolish-area-btn" data-building="demolish-area" style="background: linear-gradient(45deg, #8e44ad, #732d91); margin-top: 5px;">
                    üóëÔ∏è Area Demolish
                    <div class="building-cost">Remove multiple buildings (coming soon)</div>
                </button>
                
                <button class="building-btn" id="expand-grid-btn" data-building="expand-grid" style="background: linear-gradient(45deg, #27ae60, #2ecc71); margin-top: 5px;">
                    üî≥ Expand Grid
                    <div class="building-cost">Add 300 cells for $100</div>
                </button>
                
                <div style="margin: 10px 0; padding: 8px; background: rgba(231,76,60,0.1); border-radius: 5px; border: 1px solid rgba(231,76,60,0.3);">
                    <div style="color: #e74c3c; font-weight: bold; font-size: 12px; margin-bottom: 5px;">üí° Demolish Tips:</div>
                    <div style="font-size: 11px; color: #ccc; line-height: 1.3;">
                        ‚Ä¢ Single: Removes top building only<br>
                        ‚Ä¢ Stack: Removes all buildings in cell<br>
                        ‚Ä¢ Full refund for all demolish operations<br>
                        ‚Ä¢ Use strategically to optimize your city
                    </div>
                </div>

                <button class="reset-btn" id="reset-btn">
                    üîÑ Reset City
                </button>
                
                <button class="building-btn" id="new-project-btn" style="background: linear-gradient(45deg, #9b59b6, #8e44ad); margin-top: 10px;">
                    üÜï New Project
                    <div class="building-cost">Start fresh with save option</div>
                </button>
                
                <button class="building-btn" id="save-btn" style="background: linear-gradient(45deg, #2ecc71, #27ae60); margin-top: 5px;">
                    üíæ Save Game
                    <div class="building-cost">Save progress to browser</div>
                </button>
                
                <button class="building-btn" id="load-btn" style="background: linear-gradient(45deg, #3498db, #2980b9); margin-top: 5px;">
                    üìÇ Load Game
                    <div class="building-cost">Load saved progress</div>
                </button>
                
                <div style="margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px; font-size: 11px; color: #ccc;">
                    * Business buildings only generate income when metro network is active (2+ stations + 1+ line)<br>
                    City buildings (üè†üè¨) always generate income, but premium buildings (üè®üèôÔ∏è) require metro network
                </div>
            </div>
        </div>

        <div class="game-board">
            <div class="grid" id="game-grid"></div>
        </div>
    </div>

    <div class="notification" id="notification"></div>

    <div class="inventory-button" id="inventory-btn">
        üì¶ Inventory
    </div>

    <div class="project-button" id="project-btn">
        üìÅ Projects
    </div>

    <div class="inventory-panel" id="inventory-panel">
        <button class="close-inventory" id="close-inventory">‚úï</button>
        <h3>üèóÔ∏è Building Inventory</h3>
        
        <div class="inventory-item">
            <div class="inventory-building">
                <span class="inventory-emoji">üöâ</span>
                <span class="inventory-name">Metro Stations</span>
            </div>
            <span class="inventory-count" id="station-count">0</span>
        </div>
        
        <div class="inventory-item">
            <div class="inventory-building">
                <span class="inventory-emoji">üõ§Ô∏è</span>
                <span class="inventory-name">Metro Lines</span>
            </div>
            <span class="inventory-count" id="line-count">0</span>
        </div>
        
        <div class="inventory-item">
            <div class="inventory-building">
                <span class="inventory-emoji">üè≠</span>
                <span class="inventory-name">Metro Depots</span>
            </div>
            <span class="inventory-count" id="depot-count">0</span>
        </div>
        
        <div class="inventory-item">
            <div class="inventory-building">
                <span class="inventory-emoji">üè¢</span>
                <span class="inventory-name">Metro Offices</span>
            </div>
            <span class="inventory-count" id="office-count">0</span>
        </div>
        
        <div class="inventory-item">
            <div class="inventory-building">
                <span class="inventory-emoji">üèõÔ∏è</span>
                <span class="inventory-name">Columns</span>
            </div>
            <span class="inventory-count" id="column-count">0</span>
        </div>
        
        <div class="inventory-item">
            <div class="inventory-building">
                <span class="inventory-emoji">üè†</span>
                <span class="inventory-name">Apartments</span>
            </div>
            <span class="inventory-count" id="apartment-count">0</span>
        </div>
        
        <div class="inventory-item">
            <div class="inventory-building">
                <span class="inventory-emoji">üè¨</span>
                <span class="inventory-name">City Offices</span>
            </div>
            <span class="inventory-count" id="cityoffice-count">0</span>
        </div>
        
        <div class="inventory-item">
            <div class="inventory-building">
                <span class="inventory-emoji">üè®</span>
                <span class="inventory-name">Hotels</span>
            </div>
            <span class="inventory-count" id="hotel-count">0</span>
        </div>
        
        <div class="inventory-item">
            <div class="inventory-building">
                <span class="inventory-emoji">üèôÔ∏è</span>
                <span class="inventory-name">Skyscrapers</span>
            </div>
            <span class="inventory-count" id="skyscraper-count">0</span>
        </div>

        <div class="inventory-stats">
            <div class="inventory-stat">
                <span>üí∞ Total Value:</span>
                <span id="total-value">$0</span>
            </div>
            <div class="inventory-stat">
                <span>üíµ Active Income:</span>
                <span id="active-income">$0/s</span>
            </div>
            <div class="inventory-stat">
                <span>üöá Network Status:</span>
                <span id="network-status-inv">Inactive</span>
            </div>
        </div>
    </div>

    <div class="project-panel" id="project-panel">
        <button class="close-project-panel" id="close-project-panel">‚úï</button>
        <h3>üìÅ Project Manager</h3>
        <div id="project-list">
            <div class="no-projects">No saved projects found</div>
        </div>
    </div>

    <script>
        class MetroCityBuilder {
            constructor() {
                this.money = 1000;
                this.population = 0;
                this.buildings = 0;
                this.income = 0;
                this.selectedBuilding = null;
                this.grid = [];
                this.gridSize = { rows: 15, cols: 20 };
                this.inventoryOpen = false;
                this.projectPanelOpen = false;
                this.currentProjectName = 'Untitled Project';
                this.railConnections = [];
                this.stationConnections = [];
                this.trains = [];
                this.trainInterval = null;
                
                this.buildingTypes = {
                    station: { cost: 100, income: 10, emoji: 'üöâ', class: 'metro-station' },
                    line: { cost: 50, income: 0, emoji: 'üõ§Ô∏è', class: 'metro-line' },
                    depot: { cost: 200, income: 25, emoji: 'üè≠', class: 'metro-depot' },
                    office: { cost: 300, income: 40, emoji: 'üè¢', class: 'metro-office' },
                    column: { cost: 75, income: 0, emoji: 'üèõÔ∏è', class: 'column' },
                    skyscraper: { cost: 500, income: 60, emoji: 'üèôÔ∏è', class: 'skyscraper' },
                    cityoffice: { cost: 250, income: 35, emoji: 'üè¨', class: 'city-office' },
                    hotel: { cost: 400, income: 50, emoji: 'üè®', class: 'hotel' },
                    apartment: { cost: 150, income: 20, emoji: 'üè†', class: 'apartment' }
                };

                this.init();
            }

            init() {
                this.createGrid();
                this.setupEventListeners();
                this.startIncomeLoop();
                this.updateUI();
                this.checkForSavedGame();
                
                // Initialize rail connections and trains
                setTimeout(() => {
                    this.updateRailConnections();
                    this.updateStationConnections();
                    this.checkAndStartTrains();
                }, 1000);
            }

            createGrid() {
                const gridElement = document.getElementById('game-grid');
                gridElement.innerHTML = '';
                this.grid = [];

                for (let row = 0; row < this.gridSize.rows; row++) {
                    this.grid[row] = [];
                    for (let col = 0; col < this.gridSize.cols; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        cell.addEventListener('click', () => this.handleCellClick(row, col));
                        
                        gridElement.appendChild(cell);
                        this.grid[row][col] = { buildings: [], element: cell };
                    }
                }
            }

            setupEventListeners() {
                // Building selection buttons
                document.querySelectorAll('.building-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const buildingType = btn.dataset.building;
                        if (buildingType) {
                            this.selectBuilding(buildingType);
                        }
                    });
                });

                // Reset button
                document.getElementById('reset-btn').addEventListener('click', () => {
                    this.resetGame();
                });

                // New Project button
                document.getElementById('new-project-btn').addEventListener('click', () => {
                    this.newProject();
                });

                // Save button
                document.getElementById('save-btn').addEventListener('click', () => {
                    this.saveGame();
                });

                // Load button
                document.getElementById('load-btn').addEventListener('click', () => {
                    this.loadGame();
                });

                // Inventory button
                document.getElementById('inventory-btn').addEventListener('click', () => {
                    this.toggleInventory();
                });

                // Project button
                document.getElementById('project-btn').addEventListener('click', () => {
                    this.toggleProjectPanel();
                });

                // Close inventory button
                document.getElementById('close-inventory').addEventListener('click', () => {
                    this.closeInventory();
                });

                // Close project panel button
                document.getElementById('close-project-panel').addEventListener('click', () => {
                    this.closeProjectPanel();
                });

                // Close inventory when clicking outside
                document.addEventListener('click', (e) => {
                    const inventoryPanel = document.getElementById('inventory-panel');
                    const inventoryBtn = document.getElementById('inventory-btn');
                    const projectPanel = document.getElementById('project-panel');
                    const projectBtn = document.getElementById('project-btn');
                    
                    if (this.inventoryOpen && 
                        !inventoryPanel.contains(e.target) && 
                        !inventoryBtn.contains(e.target)) {
                        this.closeInventory();
                    }
                    
                    if (this.projectPanelOpen && 
                        !projectPanel.contains(e.target) && 
                        !projectBtn.contains(e.target)) {
                        this.closeProjectPanel();
                    }
                });
            }

            selectBuilding(type) {
                this.selectedBuilding = type;
                
                // Update button states
                document.querySelectorAll('.building-btn').forEach(btn => {
                    btn.classList.remove('selected-building');
                });
                
                const selectedBtn = document.querySelector(`[data-building="${type}"]`);
                if (selectedBtn) {
                    selectedBtn.classList.add('selected-building');
                }

                if (type === 'demolish') {
                    this.showNotification('üß® Demolish Mode: Click on buildings to remove them (full refund)', 'success');
                } else if (type === 'demolish-stack') {
                    this.showNotification('üí• Demolish Stack Mode: Click on buildings to remove entire stack (full refund)', 'success');
                } else if (type === 'demolish-area') {
                    this.showNotification('üóëÔ∏è Area Demolish Mode: Coming soon - will allow multi-cell demolition', 'success');
                } else if (type === 'expand-grid') {
                    this.expandGrid();
                    return; // Don't set as selected building, just execute the action
                } else {
                    this.showNotification(`Selected: ${this.buildingTypes[type].emoji} ${type.charAt(0).toUpperCase() + type.slice(1)}`, 'success');
                }
            }

            handleCellClick(row, col) {
                const cell = this.grid[row][col];
                
                if (!this.selectedBuilding) {
                    if (cell.buildings.length > 0) {
                        this.showBuildingInfo(cell);
                    } else {
                        this.showNotification('Please select a building type first!', 'error');
                    }
                    return;
                }

                // Handle demolish mode
                if (this.selectedBuilding === 'demolish') {
                    if (cell.buildings.length === 0) {
                        this.showNotification('No buildings to demolish here!', 'error');
                        return;
                    }
                    this.demolishBuilding(row, col);
                    return;
                }
                
                // Handle demolish stack mode
                if (this.selectedBuilding === 'demolish-stack') {
                    if (cell.buildings.length === 0) {
                        this.showNotification('No buildings to demolish here!', 'error');
                        return;
                    }
                    this.demolishStack(row, col);
                    return;
                }
                
                // Handle area demolish mode (coming soon)
                if (this.selectedBuilding === 'demolish-area') {
                    this.showNotification('üóëÔ∏è Area Demolish feature coming soon! For now, use Single or Stack demolish.', 'error');
                    return;
                }
                
                // Check if cell has a skyscraper - prevent building on top of skyscrapers
                const hasSkyscraper = cell.buildings.some(building => building.type === 'skyscraper');
                if (hasSkyscraper) {
                    this.showNotification('Cannot build on top of skyscrapers!', 'error');
                    return;
                }

                const buildingType = this.buildingTypes[this.selectedBuilding];
                
                // Check if this is a multi-level building (city office or hotel)
                if (this.selectedBuilding === 'cityoffice' || this.selectedBuilding === 'hotel') {
                    this.promptForLevels(row, col, this.selectedBuilding);
                    return;
                }
                
                if (this.money < buildingType.cost) {
                    this.showNotification('Not enough money!', 'error');
                    return;
                }

                this.buildBuilding(row, col, this.selectedBuilding);
            }

            promptForLevels(row, col, buildingType) {
                const buildingData = this.buildingTypes[buildingType];
                const buildingName = buildingType === 'cityoffice' ? 'City Office' : 'Hotel';
                
                // Calculate max levels based on available money
                const maxLevels = Math.floor(this.money / buildingData.cost);
                
                if (maxLevels === 0) {
                    this.showNotification('Not enough money!', 'error');
                    return;
                }
                
                const levels = prompt(
                    `How many levels of ${buildingName} would you like to build?\n` +
                    `Cost per level: $${buildingData.cost}\n` +
                    `Available money: $${this.money}\n` +
                    `Maximum levels: ${maxLevels}`,
                    '1'
                );
                
                if (levels === null) {
                    // User cancelled
                    return;
                }
                
                const numLevels = parseInt(levels);
                
                if (isNaN(numLevels) || numLevels < 1) {
                    this.showNotification('Please enter a valid number of levels!', 'error');
                    return;
                }
                
                if (numLevels > maxLevels) {
                    this.showNotification(`Not enough money for ${numLevels} levels! Maximum: ${maxLevels}`, 'error');
                    return;
                }
                
                const totalCost = numLevels * buildingData.cost;
                
                if (this.money < totalCost) {
                    this.showNotification('Not enough money!', 'error');
                    return;
                }
                
                // Build multiple levels
                this.buildMultipleLevels(row, col, buildingType, numLevels);
                
                // Debug: Verify the stack was built correctly
                const cell = this.grid[row][col];
                console.log(`Built ${numLevels} levels. Cell now has ${cell.buildings.length} buildings.`);
            }

            buildMultipleLevels(row, col, type, levels) {
                const buildingType = this.buildingTypes[type];
                const cell = this.grid[row][col];
                const totalCost = levels * buildingType.cost;
                
                // Deduct total money
                this.money -= totalCost;
                
                // Add multiple buildings to stack
                for (let i = 0; i < levels; i++) {
                    cell.buildings.push({ type, income: buildingType.income });
                }
                
                // Update stats
                this.buildings += levels;
                this.income += buildingType.income * levels;
                
                // Population calculation based on building type
                let populationPerLevel = 0;
                if (type === 'cityoffice') populationPerLevel = 75;
                else if (type === 'hotel') populationPerLevel = 120;
                
                this.population += populationPerLevel * levels;
                
                // Update visual representation - do this after all stats are updated
                this.updateCellVisual(cell);
                this.updateUI();
                
                const stackCount = cell.buildings.length;
                const levelText = levels > 1 ? `${levels} levels` : '1 level';
                const buildingName = type === 'cityoffice' ? 'City Office' : type === 'hotel' ? 'Hotel' : type;
                this.showNotification(`Built ${levelText} of ${buildingType.emoji} ${buildingName}! Total in stack: ${stackCount}`, 'success');
                
                // Check if metro network just became active
                const stationCount = this.countBuildingType('station');
                const lineCount = this.countBuildingType('line');
                if (stationCount >= 2 && lineCount >= 1) {
                    setTimeout(() => {
                        this.showNotification('üöá Metro Network Active! Business buildings now generate income!', 'success');
                    }, 1000);
                }
            }

            buildBuilding(row, col, type) {
                const buildingType = this.buildingTypes[type];
                const cell = this.grid[row][col];

                // Deduct money
                this.money -= buildingType.cost;
                
                // Add building to stack
                cell.buildings.push({ type, income: buildingType.income });

                // Update visual representation
                this.updateCellVisual(cell);

                // Update stats
                this.buildings++;
                this.income += buildingType.income;
                
                // Population calculation based on building type
                if (type === 'station') this.population += 50;
                else if (type === 'office') this.population += 100;
                else if (type === 'apartment') this.population += 80;
                else if (type === 'cityoffice') this.population += 75;
                else if (type === 'hotel') this.population += 120;
                else if (type === 'skyscraper') this.population += 200;
                else if (type === 'column') this.population += 5;
                else this.population += 25;

                this.updateUI();
                
                const stackCount = cell.buildings.length;
                const stackText = stackCount > 1 ? ` (Stack: ${stackCount})` : '';
                this.showNotification(`Built ${buildingType.emoji} ${type}!${stackText}`, 'success');

                // Handle rail connections and trains
                if (type === 'line') {
                    this.updateRailConnections();
                    this.checkAndStartTrains();
                } else if (type === 'station') {
                    this.updateStationConnections();
                    this.checkAndStartTrains();
                }

                // Check if metro network just became active
                const stationCount = this.countBuildingType('station');
                const lineCount = this.countBuildingType('line');
                if (stationCount >= 2 && lineCount >= 1) {
                    setTimeout(() => {
                        this.showNotification('üöá Metro Network Active! Business buildings now generate income!', 'success');
                    }, 1000);
                }
            }

            demolishBuilding(row, col) {
                const cell = this.grid[row][col];
                
                if (cell.buildings.length === 0) {
                    this.showNotification('No buildings to demolish!', 'error');
                    return;
                }

                // Remove the topmost building
                const removedBuilding = cell.buildings.pop();
                const buildingType = this.buildingTypes[removedBuilding.type];
                
                // Refund full building cost
                const refund = buildingType.cost;
                this.money += refund;
                
                // Update visual representation
                this.updateCellVisual(cell);

                // Update stats
                this.buildings--;
                this.income -= removedBuilding.income;
                
                // Remove population based on building type
                if (removedBuilding.type === 'station') this.population -= 50;
                else if (removedBuilding.type === 'office') this.population -= 100;
                else if (removedBuilding.type === 'apartment') this.population -= 80;
                else if (removedBuilding.type === 'cityoffice') this.population -= 75;
                else if (removedBuilding.type === 'hotel') this.population -= 120;
                else if (removedBuilding.type === 'skyscraper') this.population -= 200;
                else if (removedBuilding.type === 'column') this.population -= 5;
                else this.population -= 25;

                // Ensure population doesn't go negative
                this.population = Math.max(0, this.population);

                this.updateUI();
                
                const stackCount = cell.buildings.length;
                const stackText = stackCount > 0 ? ` (${stackCount} remaining)` : '';
                this.showNotification(`Demolished ${buildingType.emoji} ${removedBuilding.type}! Refund: $${refund}${stackText}`, 'success');

                // Handle rail connections and trains
                if (removedBuilding.type === 'line') {
                    this.updateRailConnections();
                    this.checkAndStartTrains();
                } else if (removedBuilding.type === 'station') {
                    this.updateStationConnections();
                    this.checkAndStartTrains();
                }

                // Check if metro network became inactive
                const stationCount = this.countBuildingType('station');
                const lineCount = this.countBuildingType('line');
                if (stationCount < 2 || lineCount < 1) {
                    setTimeout(() => {
                        this.showNotification('‚ö†Ô∏è Metro Network Inactive! Premium buildings stopped generating income!', 'error');
                    }, 1000);
                }
            }

            demolishStack(row, col) {
                const cell = this.grid[row][col];
                
                if (cell.buildings.length === 0) {
                    this.showNotification('No buildings to demolish!', 'error');
                    return;
                }

                const stackCount = cell.buildings.length;
                
                // Show confirmation dialog
                const confirmDemolish = confirm(
                    `üí• Demolish entire stack?\n\n` +
                    `Stack contains ${stackCount} building${stackCount > 1 ? 's' : ''}:\n` +
                    this.getStackDescription(cell) + '\n\n' +
                    `Total refund: $${this.calculateStackRefund(cell)}\n\n` +
                    `This action cannot be undone!`
                );

                if (!confirmDemolish) {
                    return;
                }

                let totalRefund = 0;
                let totalIncomeReduction = 0;
                let totalPopulationReduction = 0;
                const buildingCounts = {};

                // Process each building in the stack
                cell.buildings.forEach(building => {
                    const buildingType = this.buildingTypes[building.type];
                    totalRefund += buildingType.cost;
                    totalIncomeReduction += building.income;
                    
                    // Count buildings for notification
                    buildingCounts[building.type] = (buildingCounts[building.type] || 0) + 1;
                    
                    // Calculate population reduction
                    if (building.type === 'station') totalPopulationReduction += 50;
                    else if (building.type === 'office') totalPopulationReduction += 100;
                    else if (building.type === 'apartment') totalPopulationReduction += 80;
                    else if (building.type === 'cityoffice') totalPopulationReduction += 75;
                    else if (building.type === 'hotel') totalPopulationReduction += 120;
                    else if (building.type === 'skyscraper') totalPopulationReduction += 200;
                    else if (building.type === 'column') totalPopulationReduction += 5;
                    else totalPopulationReduction += 25;
                });

                // Clear the entire stack
                cell.buildings = [];
                
                // Update stats
                this.money += totalRefund;
                this.buildings -= stackCount;
                this.income -= totalIncomeReduction;
                this.population -= totalPopulationReduction;
                
                // Ensure population doesn't go negative
                this.population = Math.max(0, this.population);

                // Update visual representation
                this.updateCellVisual(cell);
                this.updateUI();

                // Create notification message
                let buildingList = '';
                Object.entries(buildingCounts).forEach(([type, count]) => {
                    const emoji = this.buildingTypes[type].emoji;
                    buildingList += `${emoji}${count} `;
                });

                this.showNotification(`üí• Stack demolished! ${buildingList}| Refund: $${totalRefund}`, 'success');

                // Handle rail connections and trains if rails or stations were demolished
                let updateRails = false;
                let updateTrains = false;
                let updateStations = false;
                Object.keys(buildingCounts).forEach(type => {
                    if (type === 'line') {
                        updateRails = true;
                        updateTrains = true;
                    } else if (type === 'station') {
                        updateTrains = true;
                        updateStations = true;
                    }
                });

                if (updateRails) {
                    this.updateRailConnections();
                }
                if (updateStations) {
                    this.updateStationConnections();
                }
                if (updateTrains) {
                    this.checkAndStartTrains();
                }

                // Check if metro network became inactive
                const stationCount = this.countBuildingType('station');
                const lineCount = this.countBuildingType('line');
                if (stationCount < 2 || lineCount < 1) {
                    setTimeout(() => {
                        this.showNotification('‚ö†Ô∏è Metro Network Inactive! Premium buildings stopped generating income!', 'error');
                    }, 1000);
                }
            }

            getStackDescription(cell) {
                const buildingCounts = {};
                cell.buildings.forEach(building => {
                    buildingCounts[building.type] = (buildingCounts[building.type] || 0) + 1;
                });

                let description = '';
                Object.entries(buildingCounts).forEach(([type, count]) => {
                    const emoji = this.buildingTypes[type].emoji;
                    const name = type.charAt(0).toUpperCase() + type.slice(1);
                    description += `${emoji} ${name}: ${count}\n`;
                });

                return description;
            }

            calculateStackRefund(cell) {
                let totalRefund = 0;
                cell.buildings.forEach(building => {
                    totalRefund += this.buildingTypes[building.type].cost;
                });
                return totalRefund;
            }

            expandGrid() {
                const expansionCost = 100;
                
                // Check if player has enough money
                if (this.money < expansionCost) {
                    this.showNotification('‚ùå Not enough money to expand grid! Need $100', 'error');
                    return;
                }

                // Confirm expansion
                const confirmExpansion = confirm(
                    `üî≥ Expand Grid?\n\n` +
                    `Cost: $${expansionCost}\n` +
                    `Current grid: ${this.gridSize.cols} √ó ${this.gridSize.rows} (${this.gridSize.cols * this.gridSize.rows} cells)\n` +
                    `New grid: ${this.gridSize.cols + 15} √ó ${this.gridSize.rows} (${(this.gridSize.cols + 15) * this.gridSize.rows} cells)\n` +
                    `Additional cells: ${15 * this.gridSize.rows}\n\n` +
                    `This will expand the grid to the right.`
                );

                if (!confirmExpansion) {
                    return;
                }

                // Deduct money
                this.money -= expansionCost;

                // Store current grid data
                const oldGrid = [];
                for (let row = 0; row < this.gridSize.rows; row++) {
                    oldGrid[row] = [];
                    for (let col = 0; col < this.gridSize.cols; col++) {
                        oldGrid[row][col] = {
                            buildings: [...this.grid[row][col].buildings]
                        };
                    }
                }

                // Update grid size
                const oldCols = this.gridSize.cols;
                this.gridSize.cols += 15;

                // Recreate grid with new size
                this.createGrid();

                // Restore buildings to existing cells
                for (let row = 0; row < this.gridSize.rows; row++) {
                    for (let col = 0; col < oldCols; col++) {
                        this.grid[row][col].buildings = oldGrid[row][col].buildings;
                        this.updateCellVisual(this.grid[row][col]);
                    }
                }

                // Update UI and connections
                this.updateUI();
                this.updateRailConnections();
                this.updateStationConnections();
                this.checkAndStartTrains();

                const newTotal = this.gridSize.cols * this.gridSize.rows;
                const addedCells = 15 * this.gridSize.rows;
                this.showNotification(`üî≥ Grid expanded! Added ${addedCells} cells. New size: ${this.gridSize.cols}√ó${this.gridSize.rows} (${newTotal} total)`, 'success');
            }

            startIncomeLoop() {
                setInterval(() => {
                    this.money += this.calculateActiveIncome();
                    this.updateUI();
                }, 1000);
            }

            calculateActiveIncome() {
                let activeIncome = 0;
                const stationCount = this.countBuildingType('station');
                const lineCount = this.countBuildingType('line');
                const isMetroNetworkActive = stationCount >= 2 && lineCount >= 1;

                // Always count station income
                activeIncome += this.countBuildingType('station') * this.buildingTypes.station.income;
                
                // City buildings that always work
                activeIncome += this.countBuildingType('apartment') * this.buildingTypes.apartment.income;
                activeIncome += this.countBuildingType('cityoffice') * this.buildingTypes.cityoffice.income;

                // Premium buildings that require metro network
                if (isMetroNetworkActive) {
                    activeIncome += this.countBuildingType('depot') * this.buildingTypes.depot.income;
                    activeIncome += this.countBuildingType('office') * this.buildingTypes.office.income;
                    activeIncome += this.countBuildingType('hotel') * this.buildingTypes.hotel.income;
                    activeIncome += this.countBuildingType('skyscraper') * this.buildingTypes.skyscraper.income;
                }

                return activeIncome;
            }

            countBuildingType(type) {
                let count = 0;
                for (let row = 0; row < this.gridSize.rows; row++) {
                    for (let col = 0; col < this.gridSize.cols; col++) {
                        const cell = this.grid[row][col];
                        count += cell.buildings.filter(building => building.type === type).length;
                    }
                }
                return count;
            }

            updateUI() {
                const stationCount = this.countBuildingType('station');
                const lineCount = this.countBuildingType('line');
                const isMetroNetworkActive = stationCount >= 2 && lineCount >= 1;
                const activeIncome = this.calculateActiveIncome();

                document.getElementById('money').textContent = `$${this.money}`;
                document.getElementById('population').textContent = this.population;
                document.getElementById('buildings').textContent = this.buildings;
                document.getElementById('income').textContent = `$${activeIncome}`;

                // Update button states based on affordability
                Object.keys(this.buildingTypes).forEach(type => {
                    const btn = document.querySelector(`[data-building="${type}"]`);
                    const cost = this.buildingTypes[type].cost;
                    
                    if (btn) {
                        btn.disabled = this.money < cost;
                        
                        // Visual indicator for buildings that require metro network
                        if ((type === 'depot' || type === 'office' || type === 'hotel' || type === 'skyscraper') && !isMetroNetworkActive) {
                            btn.style.opacity = '0.6';
                            btn.title = 'Requires 2+ Metro Stations and 1+ Metro Line to generate income';
                        } else {
                            btn.style.opacity = '1';
                            btn.title = '';
                        }
                    }
                });

                // Demolish button is always enabled
                const demolishBtn = document.querySelector('[data-building="demolish"]');
                if (demolishBtn) {
                    demolishBtn.disabled = false;
                    demolishBtn.style.opacity = '1';
                }

                // Demolish stack button is always enabled
                const demolishStackBtn = document.querySelector('[data-building="demolish-stack"]');
                if (demolishStackBtn) {
                    demolishStackBtn.disabled = false;
                    demolishStackBtn.style.opacity = '1';
                }

                // Demolish area button is always enabled
                const demolishAreaBtn = document.querySelector('[data-building="demolish-area"]');
                if (demolishAreaBtn) {
                    demolishAreaBtn.disabled = false;
                    demolishAreaBtn.style.opacity = '0.6'; // Slightly dimmed since it's coming soon
                    demolishAreaBtn.title = 'Feature coming soon - multi-cell demolition';
                }

                // Show metro network status
                this.updateNetworkStatus(isMetroNetworkActive, stationCount, lineCount);
                this.updateInventory();
                this.updateGridVisuals();
            }

            showNotification(message, type = 'success') {
                const notification = document.getElementById('notification');
                notification.textContent = message;
                notification.className = `notification ${type}`;
                notification.classList.add('show');

                setTimeout(() => {
                    notification.classList.remove('show');
                }, 3000);
            }

            resetGame() {
                if (confirm('Are you sure you want to reset your city? This will delete all progress.')) {
                    this.money = 1000;
                    this.population = 0;
                    this.buildings = 0;
                    this.income = 0;
                    this.selectedBuilding = null;
                    
                    this.createGrid();
                    this.updateUI();
                    this.showNotification('City reset successfully!', 'success');
                }
            }

            newProject() {
                // Check if there's any progress to save
                if (this.buildings > 0 || this.money !== 1000) {
                    const saveChoice = confirm(
                        'üÜï Starting a new project will reset your current city.\n\n' +
                        'Would you like to save your current progress first?\n\n' +
                        'Click "OK" to save and continue\n' +
                        'Click "Cancel" to start new project without saving'
                    );

                    if (saveChoice) {
                        // User chose to save first
                        this.saveGame();
                        
                        // Give a moment for the save notification to show, then ask to proceed
                        setTimeout(() => {
                            const proceedChoice = confirm(
                                'üíæ Game saved!\n\n' +
                                'Now start the new project?'
                            );
                            
                            if (proceedChoice) {
                                this.startNewProject();
                            }
                        }, 1500);
                    } else {
                        // User chose not to save, confirm they want to proceed
                        const finalChoice = confirm(
                            '‚ö†Ô∏è Are you sure you want to start a new project without saving?\n\n' +
                            'Your current progress will be lost!'
                        );
                        
                        if (finalChoice) {
                            this.startNewProject();
                        }
                    }
                } else {
                    // No progress to lose, just start new project
                    this.startNewProject();
                }
            }

            startNewProject() {
                this.money = 1000;
                this.population = 0;
                this.buildings = 0;
                this.income = 0;
                this.selectedBuilding = null;
                this.currentProjectName = 'Untitled Project';
                
                // Stop trains and clear connections
                this.stopTrains();
                this.railConnections = [];
                this.stationConnections = [];
                
                // Clear existing station connection visuals
                document.querySelectorAll('.station-connection').forEach(el => el.remove());
                document.querySelectorAll('.connected-station').forEach(el => {
                    el.classList.remove('connected-station');
                    const indicator = el.querySelector('.connection-indicator');
                    if (indicator) indicator.remove();
                });
                
                this.createGrid();
                this.updateUI();
                this.showNotification('üÜï New project started! Welcome to Metro City Builder!', 'success');
            }

            updateNetworkStatus(isActive, stationCount, lineCount) {
                const statusElement = document.getElementById('network-status');
                if (isActive) {
                    statusElement.textContent = 'Active ‚úÖ';
                    statusElement.style.color = '#4CAF50';
                } else {
                    statusElement.textContent = `Need ${Math.max(0, 2 - stationCount)} stations, ${Math.max(0, 1 - lineCount)} lines`;
                    statusElement.style.color = '#f44336';
                }
            }

            toggleInventory() {
                this.inventoryOpen = !this.inventoryOpen;
                const panel = document.getElementById('inventory-panel');
                
                if (this.inventoryOpen) {
                    panel.classList.add('show');
                    this.updateInventory();
                } else {
                    panel.classList.remove('show');
                }
            }

            closeInventory() {
                this.inventoryOpen = false;
                document.getElementById('inventory-panel').classList.remove('show');
            }

            updateInventory() {
                const stationCount = this.countBuildingType('station');
                const lineCount = this.countBuildingType('line');
                const depotCount = this.countBuildingType('depot');
                const officeCount = this.countBuildingType('office');
                const columnCount = this.countBuildingType('column');
                const apartmentCount = this.countBuildingType('apartment');
                const cityofficeCount = this.countBuildingType('cityoffice');
                const hotelCount = this.countBuildingType('hotel');
                const skyscraperCount = this.countBuildingType('skyscraper');
                const isMetroNetworkActive = stationCount >= 2 && lineCount >= 1;
                const activeIncome = this.calculateActiveIncome();

                // Update counts
                document.getElementById('station-count').textContent = stationCount;
                document.getElementById('line-count').textContent = lineCount;
                document.getElementById('depot-count').textContent = depotCount;
                document.getElementById('office-count').textContent = officeCount;
                document.getElementById('column-count').textContent = columnCount;
                document.getElementById('apartment-count').textContent = apartmentCount;
                document.getElementById('cityoffice-count').textContent = cityofficeCount;
                document.getElementById('hotel-count').textContent = hotelCount;
                document.getElementById('skyscraper-count').textContent = skyscraperCount;

                // Calculate total value
                const totalValue = 
                    stationCount * this.buildingTypes.station.cost +
                    lineCount * this.buildingTypes.line.cost +
                    depotCount * this.buildingTypes.depot.cost +
                    officeCount * this.buildingTypes.office.cost +
                    columnCount * this.buildingTypes.column.cost +
                    apartmentCount * this.buildingTypes.apartment.cost +
                    cityofficeCount * this.buildingTypes.cityoffice.cost +
                    hotelCount * this.buildingTypes.hotel.cost +
                    skyscraperCount * this.buildingTypes.skyscraper.cost;

                document.getElementById('total-value').textContent = `$${totalValue}`;
                document.getElementById('active-income').textContent = `$${activeIncome}/s`;

                // Update network status in inventory
                const networkStatusInv = document.getElementById('network-status-inv');
                if (isMetroNetworkActive) {
                    networkStatusInv.textContent = 'Active ‚úÖ';
                    networkStatusInv.style.color = '#4CAF50';
                } else {
                    networkStatusInv.textContent = 'Inactive ‚ùå';
                    networkStatusInv.style.color = '#f44336';
                }
            }

            updateCellVisual(cell) {
                // Clear existing visual and connection styles
                cell.element.innerHTML = '';
                cell.element.classList.remove('connected-station');
                
                if (cell.buildings.length === 0) {
                    cell.element.classList.remove('occupied');
                    return;
                }

                cell.element.classList.add('occupied');

                // Show the topmost building
                const topBuilding = cell.buildings[cell.buildings.length - 1];
                const buildingType = this.buildingTypes[topBuilding.type];
                
                const building = document.createElement('div');
                building.className = `building ${buildingType.class}`;
                building.textContent = buildingType.emoji;
                
                // Add stack indicator if more than one building
                if (cell.buildings.length > 1) {
                    const stackIndicator = document.createElement('div');
                    stackIndicator.className = 'building-stack';
                    stackIndicator.textContent = cell.buildings.length;
                    building.appendChild(stackIndicator);
                }

                // Add layer indicators
                if (cell.buildings.length > 1) {
                    const layersContainer = document.createElement('div');
                    layersContainer.className = 'building-layers';
                    
                    cell.buildings.forEach(b => {
                        const layer = document.createElement('div');
                        layer.className = 'layer-indicator';
                        layer.style.backgroundColor = this.getBuildingColor(b.type);
                        layersContainer.appendChild(layer);
                    });
                    
                    building.appendChild(layersContainer);
                }

                cell.element.appendChild(building);
            }

            getBuildingColor(type) {
                const colors = {
                    station: '#e74c3c',
                    line: '#3498db',
                    depot: '#9b59b6',
                    office: '#f39c12',
                    column: '#95a5a6',
                    skyscraper: '#34495e',
                    cityoffice: '#16a085',
                    hotel: '#e91e63',
                    apartment: '#8e44ad'
                };
                return colors[type] || '#fff';
            }

            showBuildingInfo(cell) {
                if (cell.buildings.length === 0) return;
                
                const buildingCounts = {};
                let totalIncome = 0;
                
                cell.buildings.forEach(building => {
                    buildingCounts[building.type] = (buildingCounts[building.type] || 0) + 1;
                    totalIncome += building.income;
                });

                let info = 'Buildings in this cell:\n';
                Object.entries(buildingCounts).forEach(([type, count]) => {
                    const emoji = this.buildingTypes[type].emoji;
                    info += `${emoji} ${type}: ${count}\n`;
                });
                
                const stationCount = this.countBuildingType('station');
                const lineCount = this.countBuildingType('line');
                const isNetworkActive = stationCount >= 2 && lineCount >= 1;
                
                // Calculate actual income from this cell
                let actualIncome = 0;
                cell.buildings.forEach(building => {
                    if (building.type === 'station' || building.type === 'apartment' || building.type === 'cityoffice') {
                        actualIncome += building.income;
                    } else if ((building.type === 'depot' || building.type === 'office' || building.type === 'hotel' || building.type === 'skyscraper') && isNetworkActive) {
                        actualIncome += building.income;
                    }
                });
                
                info += `üíµ Cell Income: $${actualIncome}/s`;
                
                this.showNotification(info, 'success');
            }

            updateGridVisuals() {
                // Update grid cell classes based on selected building mode
                for (let row = 0; row < this.gridSize.rows; row++) {
                    for (let col = 0; col < this.gridSize.cols; col++) {
                        const cell = this.grid[row][col];
                        
                        if (this.selectedBuilding === 'demolish' || this.selectedBuilding === 'demolish-stack' || this.selectedBuilding === 'demolish-area') {
                            if (cell.buildings.length > 0) {
                                cell.element.classList.add('demolish-mode');
                            }
                        } else {
                            cell.element.classList.remove('demolish-mode');
                        }
                    }
                }
            }

            updateRailConnections() {
                // Clear existing connections
                document.querySelectorAll('.rail-connection').forEach(el => el.remove());
                this.railConnections = [];

                // Find all rail cells
                const railCells = [];
                for (let row = 0; row < this.gridSize.rows; row++) {
                    for (let col = 0; col < this.gridSize.cols; col++) {
                        const cell = this.grid[row][col];
                        if (cell.buildings.some(building => building.type === 'line')) {
                            railCells.push({ row, col, element: cell.element });
                        }
                    }
                }

                // Create connections between adjacent rails
                railCells.forEach(rail => {
                    const { row, col, element } = rail;
                    
                    // Check all 4 directions for adjacent rails
                    const directions = [
                        { dr: 0, dc: 1, class: 'rail-horizontal' },   // Right
                        { dr: 1, dc: 0, class: 'rail-vertical' },    // Down
                        { dr: 0, dc: -1, class: 'rail-horizontal' },  // Left
                        { dr: -1, dc: 0, class: 'rail-vertical' }    // Up
                    ];

                    directions.forEach(dir => {
                        const newRow = row + dir.dr;
                        const newCol = col + dir.dc;
                        
                        if (newRow >= 0 && newRow < this.gridSize.rows && 
                            newCol >= 0 && newCol < this.gridSize.cols) {
                            
                            const adjacentCell = this.grid[newRow][newCol];
                            if (adjacentCell.buildings.some(building => building.type === 'line')) {
                                // Create visual connection
                                this.createRailConnection(rail, { row: newRow, col: newCol }, dir.class);
                                
                                // Store connection data
                                this.railConnections.push({
                                    from: { row, col },
                                    to: { row: newRow, col: newCol }
                                });
                            }
                        }
                    });
                });
            }

            createRailConnection(fromRail, toRail, connectionClass) {
                const gridElement = document.getElementById('game-grid');
                const connection = document.createElement('div');
                connection.className = `rail-connection ${connectionClass}`;
                
                const fromRect = fromRail.element.getBoundingClientRect();
                const gridRect = gridElement.getBoundingClientRect();
                
                if (connectionClass === 'rail-horizontal') {
                    connection.style.left = `${fromRect.left - gridRect.left + fromRect.width}px`;
                    connection.style.top = `${fromRect.top - gridRect.top + fromRect.height / 2}px`;
                    connection.style.width = `2px`; // Gap between cells
                } else if (connectionClass === 'rail-vertical') {
                    connection.style.left = `${fromRect.left - gridRect.left + fromRect.width / 2}px`;
                    connection.style.top = `${fromRect.top - gridRect.top + fromRect.height}px`;
                    connection.style.height = `2px`; // Gap between cells
                }
                
                gridElement.appendChild(connection);
            }

            checkAndStartTrains() {
                // Stop existing trains
                this.stopTrains();

                // Check if we have enough stations and rails for trains
                const stationCount = this.countBuildingType('station');
                const lineCount = this.countBuildingType('line');

                if (stationCount >= 2 && lineCount >= 1) {
                    this.startTrains();
                }
            }

            startTrains() {
                // Find all stations
                const stations = [];
                for (let row = 0; row < this.gridSize.rows; row++) {
                    for (let col = 0; col < this.gridSize.cols; col++) {
                        const cell = this.grid[row][col];
                        if (cell.buildings.some(building => building.type === 'station')) {
                            stations.push({ row, col, element: cell.element });
                        }
                    }
                }

                if (stations.length < 2) return;

                // Create trains that move between connected stations
                this.trainInterval = setInterval(() => {
                    if (Math.random() < 0.3) { // 30% chance to spawn a train each interval
                        this.spawnTrain(stations);
                    }
                }, 3000);
            }

            spawnTrain(stations) {
                // Pick a random starting station
                const startStation = stations[Math.floor(Math.random() * stations.length)];
                
                // Find connected stations via rail network
                const connectedStations = this.findConnectedStations(startStation, stations);
                
                if (connectedStations.length === 0) return;

                // Pick a random destination
                const endStation = connectedStations[Math.floor(Math.random() * connectedStations.length)];
                
                // Create train element
                const train = document.createElement('div');
                train.className = 'train';
                train.textContent = 'üöá';
                
                // Position train at start station
                const gridElement = document.getElementById('game-grid');
                const startRect = startStation.element.getBoundingClientRect();
                const gridRect = gridElement.getBoundingClientRect();
                
                train.style.left = `${startRect.left - gridRect.left}px`;
                train.style.top = `${startRect.top - gridRect.top}px`;
                
                gridElement.appendChild(train);
                
                // Animate train to destination
                this.animateTrainToDestination(train, startStation, endStation);
            }

            findConnectedStations(startStation, allStations) {
                // Simple pathfinding - check if there's a rail path to other stations
                const connected = [];
                
                allStations.forEach(station => {
                    if (station.row === startStation.row && station.col === startStation.col) return;
                    
                    // Check if there's a rail path (simplified - adjacent or nearby rails)
                    if (this.hasRailPath(startStation, station)) {
                        connected.push(station);
                    }
                });
                
                return connected;
            }

            hasRailPath(from, to) {
                // Simplified path checking - look for rails in between
                const rowDiff = Math.abs(to.row - from.row);
                const colDiff = Math.abs(to.col - from.col);
                
                // Check horizontal path
                if (rowDiff === 0 && colDiff > 1) {
                    const startCol = Math.min(from.col, to.col);
                    const endCol = Math.max(from.col, to.col);
                    
                    for (let col = startCol + 1; col < endCol; col++) {
                        const cell = this.grid[from.row][col];
                        if (!cell.buildings.some(building => building.type === 'line')) {
                            return false;
                        }
                    }
                    return true;
                }
                
                // Check vertical path
                if (colDiff === 0 && rowDiff > 1) {
                    const startRow = Math.min(from.row, to.row);
                    const endRow = Math.max(from.row, to.row);
                    
                    for (let row = startRow + 1; row < endRow; row++) {
                        const cell = this.grid[row][from.col];
                        if (!cell.buildings.some(building => building.type === 'line')) {
                            return false;
                        }
                    }
                    return true;
                }
                
                // Adjacent stations
                if ((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1)) {
                    return true;
                }
                
                return false;
            }

            animateTrainToDestination(train, start, end) {
                const startRect = start.element.getBoundingClientRect();
                const endRect = end.element.getBoundingClientRect();
                const gridRect = document.getElementById('game-grid').getBoundingClientRect();
                
                const startX = startRect.left - gridRect.left;
                const startY = startRect.top - gridRect.top;
                const endX = endRect.left - gridRect.left;
                const endY = endRect.top - gridRect.top;
                
                train.style.transition = 'all 4s linear';
                train.style.left = `${endX}px`;
                train.style.top = `${endY}px`;
                
                // Remove train after animation
                setTimeout(() => {
                    if (train.parentNode) {
                        train.remove();
                    }
                }, 4000);
            }

            stopTrains() {
                // Clear train interval
                if (this.trainInterval) {
                    clearInterval(this.trainInterval);
                    this.trainInterval = null;
                }
                
                // Remove all existing trains
                document.querySelectorAll('.train').forEach(train => train.remove());
                this.trains = [];
            }

            updateStationConnections() {
                // Clear existing station connections
                document.querySelectorAll('.station-connection').forEach(el => el.remove());
                this.stationConnections = this.stationConnections || [];
                this.stationConnections = [];

                // Find all station cells
                const stationCells = [];
                for (let row = 0; row < this.gridSize.rows; row++) {
                    for (let col = 0; col < this.gridSize.cols; col++) {
                        const cell = this.grid[row][col];
                        if (cell.buildings.some(building => building.type === 'station')) {
                            stationCells.push({ row, col, element: cell.element });
                        }
                    }
                }

                // Group adjacent stations into connected clusters
                const stationClusters = this.findStationClusters(stationCells);
                
                // Update visual representation for each cluster
                stationClusters.forEach(cluster => {
                    if (cluster.length > 1) {
                        this.visualizeStationCluster(cluster);
                    }
                });
            }

            findStationClusters(stationCells) {
                const visited = new Set();
                const clusters = [];

                stationCells.forEach(station => {
                    const key = `${station.row},${station.col}`;
                    if (!visited.has(key)) {
                        const cluster = [];
                        this.exploreStationCluster(station, stationCells, visited, cluster);
                        clusters.push(cluster);
                    }
                });

                return clusters;
            }

            exploreStationCluster(station, allStations, visited, cluster) {
                const key = `${station.row},${station.col}`;
                if (visited.has(key)) return;

                visited.add(key);
                cluster.push(station);

                // Check all 4 directions for adjacent stations
                const directions = [
                    { dr: 0, dc: 1 },   // Right
                    { dr: 1, dc: 0 },   // Down
                    { dr: 0, dc: -1 },  // Left
                    { dr: -1, dc: 0 }   // Up
                ];

                directions.forEach(dir => {
                    const newRow = station.row + dir.dr;
                    const newCol = station.col + dir.dc;
                    
                    const adjacentStation = allStations.find(s => s.row === newRow && s.col === newCol);
                    if (adjacentStation) {
                        this.exploreStationCluster(adjacentStation, allStations, visited, cluster);
                    }
                });
            }

            visualizeStationCluster(cluster) {
                const gridElement = document.getElementById('game-grid');
                
                // Calculate cluster bounds
                const minRow = Math.min(...cluster.map(s => s.row));
                const maxRow = Math.max(...cluster.map(s => s.row));
                const minCol = Math.min(...cluster.map(s => s.col));
                const maxCol = Math.max(...cluster.map(s => s.col));

                // Create connection overlay for the cluster
                const connection = document.createElement('div');
                connection.className = 'station-connection';
                
                // Get grid information for positioning
                const gridRect = gridElement.getBoundingClientRect();
                const firstCell = cluster[0].element;
                const firstRect = firstCell.getBoundingClientRect();
                
                const cellWidth = firstRect.width;
                const cellHeight = firstRect.height;
                const gap = 2; // Grid gap
                
                // Calculate overlay position and size
                const left = (minCol * (cellWidth + gap)) + 10; // Grid padding
                const top = (minRow * (cellHeight + gap)) + 10; // Grid padding
                const width = (maxCol - minCol + 1) * (cellWidth + gap) - gap;
                const height = (maxRow - minRow + 1) * (cellHeight + gap) - gap;
                
                connection.style.left = `${left}px`;
                connection.style.top = `${top}px`;
                connection.style.width = `${width}px`;
                connection.style.height = `${height}px`;
                
                gridElement.appendChild(connection);

                // Add visual indicators to each station in the cluster
                cluster.forEach(station => {
                    station.element.classList.add('connected-station');
                    
                    // Add connection indicators
                    const stationBuilding = station.element.querySelector('.building');
                    if (stationBuilding && !stationBuilding.querySelector('.connection-indicator')) {
                        const indicator = document.createElement('div');
                        indicator.className = 'connection-indicator';
                        indicator.textContent = 'üîó';
                        stationBuilding.appendChild(indicator);
                    }
                });

                // Store connection data
                this.stationConnections.push({
                    cluster: cluster.map(s => ({ row: s.row, col: s.col })),
                    bounds: { minRow, maxRow, minCol, maxCol }
                });
            }

            saveGame() {
                try {
                    // Prompt for project name if it's untitled or user wants to rename
                    let projectName = this.currentProjectName;
                    if (projectName === 'Untitled Project') {
                        projectName = prompt('Enter a name for your project:', 'My City Project');
                        if (!projectName || projectName.trim() === '') {
                            this.showNotification('‚ùå Save cancelled - no project name provided!', 'error');
                            return;
                        }
                        projectName = projectName.trim();
                        this.currentProjectName = projectName;
                    }

                    // Create save data object
                    const saveData = {
                        name: projectName,
                        money: this.money,
                        population: this.population,
                        buildings: this.buildings,
                        income: this.income,
                        grid: [],
                        timestamp: new Date().toISOString()
                    };

                    // Save grid data
                    for (let row = 0; row < this.gridSize.rows; row++) {
                        saveData.grid[row] = [];
                        for (let col = 0; col < this.gridSize.cols; col++) {
                            saveData.grid[row][col] = {
                                buildings: this.grid[row][col].buildings
                            };
                        }
                    }

                    // Get existing projects
                    const existingProjects = this.getAllProjects();
                    existingProjects[projectName] = saveData;

                    // Save to localStorage
                    localStorage.setItem('metroCityBuilderProjects', JSON.stringify(existingProjects));
                    
                    const saveTime = new Date().toLocaleString();
                    this.showNotification(`üíæ Project "${projectName}" saved successfully! (${saveTime})`, 'success');
                    
                    // Update project panel if open
                    if (this.projectPanelOpen) {
                        this.updateProjectList();
                    }
                } catch (error) {
                    console.error('Save failed:', error);
                    this.showNotification('‚ùå Failed to save project!', 'error');
                }
            }

            loadGame() {
                try {
                    const savedData = localStorage.getItem('metroCityBuilderSave');
                    
                    if (!savedData) {
                        this.showNotification('‚ùå No saved game found!', 'error');
                        return;
                    }

                    const saveData = JSON.parse(savedData);
                    const saveTime = new Date(saveData.timestamp).toLocaleString();
                    
                    const confirmLoad = confirm(
                        `Load saved game from ${saveTime}?\n\n` +
                        `Saved stats:\n` +
                        `üí∞ Money: $${saveData.money}\n` +
                        `üë• Population: ${saveData.population}\n` +
                        `üè¢ Buildings: ${saveData.buildings}\n\n` +
                        `This will overwrite your current progress!`
                    );

                    if (!confirmLoad) {
                        return;
                    }

                    // Restore game state
                    this.money = saveData.money;
                    this.population = saveData.population;
                    this.buildings = saveData.buildings;
                    this.income = saveData.income;

                    // Clear current grid
                    this.createGrid();

                    // Restore grid buildings
                    for (let row = 0; row < this.gridSize.rows; row++) {
                        for (let col = 0; col < this.gridSize.cols; col++) {
                            if (saveData.grid[row] && saveData.grid[row][col]) {
                                this.grid[row][col].buildings = saveData.grid[row][col].buildings || [];
                                this.updateCellVisual(this.grid[row][col]);
                            }
                        }
                    }

                    // Update UI
                    this.updateUI();
                    
                    // Update rail and station connections
                    this.updateRailConnections();
                    this.updateStationConnections();
                    this.checkAndStartTrains();
                    
                    this.showNotification(`üìÇ Game loaded successfully! (${saveTime})`, 'success');
                } catch (error) {
                    console.error('Load failed:', error);
                    this.showNotification('‚ùå Failed to load game!', 'error');
                }
            }

            // Check if there's a saved game on startup
            checkForSavedGame() {
                const savedData = localStorage.getItem('metroCityBuilderSave');
                if (savedData) {
                    try {
                        const saveData = JSON.parse(savedData);
                        const saveTime = new Date(saveData.timestamp).toLocaleString();
                        
                        setTimeout(() => {
                            this.showNotification(`üíæ Saved game found from ${saveTime}. Click Load Game to restore it.`, 'success');
                        }, 2000);
                    } catch (error) {
                        console.error('Error checking saved game:', error);
                    }
                }
                
                // Also check for projects
                const projects = this.getAllProjects();
                if (Object.keys(projects).length > 0) {
                    setTimeout(() => {
                        this.showNotification(`üìÅ ${Object.keys(projects).length} saved project(s) found. Open Projects panel to manage them.`, 'success');
                    }, 4000);
                }
            }

            getAllProjects() {
                try {
                    const projectsData = localStorage.getItem('metroCityBuilderProjects');
                    return projectsData ? JSON.parse(projectsData) : {};
                } catch (error) {
                    console.error('Error loading projects:', error);
                    return {};
                }
            }

            toggleProjectPanel() {
                this.projectPanelOpen = !this.projectPanelOpen;
                const panel = document.getElementById('project-panel');
                
                if (this.projectPanelOpen) {
                    panel.classList.add('show');
                    this.updateProjectList();
                } else {
                    panel.classList.remove('show');
                }
            }

            closeProjectPanel() {
                this.projectPanelOpen = false;
                document.getElementById('project-panel').classList.remove('show');
            }

            updateProjectList() {
                const projectList = document.getElementById('project-list');
                const projects = this.getAllProjects();
                
                if (Object.keys(projects).length === 0) {
                    projectList.innerHTML = '<div class="no-projects">No saved projects found</div>';
                    return;
                }

                let html = '';
                Object.entries(projects).forEach(([name, data]) => {
                    const saveTime = new Date(data.timestamp).toLocaleString();
                    const isCurrent = name === this.currentProjectName;
                    
                    html += `
                        <div class="project-item ${isCurrent ? 'current' : ''}" data-project-name="${name}">
                            <div class="project-name">${name} ${isCurrent ? '(Current)' : ''}</div>
                            <div class="project-stats">
                                üí∞ $${data.money} | üë• ${data.population} | üè¢ ${data.buildings}
                            </div>
                            <div class="project-date">Saved: ${saveTime}</div>
                            <div class="project-actions">
                                <button class="project-action-btn load" onclick="game.loadProject('${name}')">
                                    üìÇ Load
                                </button>
                                <button class="project-action-btn rename" onclick="game.renameProject('${name}')">
                                    ‚úèÔ∏è Rename
                                </button>
                                <button class="project-action-btn delete" onclick="game.deleteProject('${name}')">
                                    üóëÔ∏è Delete
                                </button>
                            </div>
                        </div>
                    `;
                });

                projectList.innerHTML = html;
            }

            loadProject(projectName) {
                try {
                    const projects = this.getAllProjects();
                    const projectData = projects[projectName];
                    
                    if (!projectData) {
                        this.showNotification('‚ùå Project not found!', 'error');
                        return;
                    }

                    const saveTime = new Date(projectData.timestamp).toLocaleString();
                    
                    const confirmLoad = confirm(
                        `Load project "${projectName}"?\n\n` +
                        `Saved: ${saveTime}\n` +
                        `üí∞ Money: $${projectData.money}\n` +
                        `üë• Population: ${projectData.population}\n` +
                        `üè¢ Buildings: ${projectData.buildings}\n\n` +
                        `This will overwrite your current progress!`
                    );

                    if (!confirmLoad) {
                        return;
                    }

                    // Restore game state
                    this.currentProjectName = projectName;
                    this.money = projectData.money;
                    this.population = projectData.population;
                    this.buildings = projectData.buildings;
                    this.income = projectData.income;

                    // Clear current grid
                    this.createGrid();

                    // Restore grid buildings
                    for (let row = 0; row < this.gridSize.rows; row++) {
                        for (let col = 0; col < this.gridSize.cols; col++) {
                            if (projectData.grid[row] && projectData.grid[row][col]) {
                                this.grid[row][col].buildings = projectData.grid[row][col].buildings || [];
                                this.updateCellVisual(this.grid[row][col]);
                            }
                        }
                    }

                    // Update UI
                    this.updateUI();
                    this.updateProjectList();
                    
                    // Restart rail connections, station connections, and trains
                    setTimeout(() => {
                        this.updateRailConnections();
                        this.updateStationConnections();
                        this.checkAndStartTrains();
                    }, 500);
                    
                    this.showNotification(`üìÇ Project "${projectName}" loaded successfully!`, 'success');
                } catch (error) {
                    console.error('Load failed:', error);
                    this.showNotification('‚ùå Failed to load project!', 'error');
                }
            }

            renameProject(oldName) {
                const newName = prompt(`Rename project "${oldName}" to:`, oldName);
                
                if (!newName || newName.trim() === '' || newName.trim() === oldName) {
                    return;
                }

                const trimmedName = newName.trim();
                const projects = this.getAllProjects();
                
                if (projects[trimmedName]) {
                    this.showNotification('‚ùå A project with that name already exists!', 'error');
                    return;
                }

                // Copy project data with new name
                projects[trimmedName] = { ...projects[oldName], name: trimmedName };
                delete projects[oldName];

                // Update current project name if this was the current project
                if (this.currentProjectName === oldName) {
                    this.currentProjectName = trimmedName;
                }

                // Save updated projects
                localStorage.setItem('metroCityBuilderProjects', JSON.stringify(projects));
                this.updateProjectList();
                this.showNotification(`‚úèÔ∏è Project renamed to "${trimmedName}"!`, 'success');
            }

            deleteProject(projectName) {
                const confirmDelete = confirm(
                    `Delete project "${projectName}"?\n\n` +
                    `This action cannot be undone!`
                );

                if (!confirmDelete) {
                    return;
                }

                const projects = this.getAllProjects();
                delete projects[projectName];

                // If this was the current project, reset to untitled
                if (this.currentProjectName === projectName) {
                    this.currentProjectName = 'Untitled Project';
                }

                localStorage.setItem('metroCityBuilderProjects', JSON.stringify(projects));
                this.updateProjectList();
                this.showNotification(`üóëÔ∏è Project "${projectName}" deleted!`, 'success');
            }
        }

        // Start the game when page loads
        let game; // Global reference for project management
        window.addEventListener('DOMContentLoaded', () => {
            game = new MetroCityBuilder();
        });
    </script>
</body>
</html>