<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Whiskers' Magic Snow Quest</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB 0%, #4682B4 50%, #2F4F4F 100%);
            font-family: Arial, sans-serif;
        }
        #msg {
            position: absolute;
            top: 0;
            color: #aaf;
            padding: 10px;
            font: 16px sans-serif;
            z-index: 100;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #aaf;
            font: 12px sans-serif;
            z-index: 100;
        }
        
        /* Settings Button */
        .settings-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 12px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            z-index: 101;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .settings-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg);
        }
        
        /* Settings Panel */
        .settings-panel {
            position: absolute;
            top: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 15px;
            min-width: 250px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 100;
            display: none;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .settings-header {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #FFB84D;
        }
        
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 5px 0;
        }
        
        .setting-label {
            font-size: 14px;
            color: #ccc;
        }
        
        .toggle-switch {
            width: 40px;
            height: 20px;
            background: #333;
            border-radius: 20px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .toggle-switch.active {
            background: #4CAF50;
        }
        
        .toggle-switch::before {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: all 0.3s ease;
        }
        
        .toggle-switch.active::before {
            transform: translateX(20px);
        }
        
        /* Hint Arrow Styles */
        .hint-arrow {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-bottom: 25px solid #FF6B35;
            z-index: 50;
            animation: bounce 1.5s infinite;
            filter: drop-shadow(0 0 10px rgba(255, 107, 53, 0.8));
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }
        
        /* Loading Screen Styles */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            color: white;
            font-family: Arial, sans-serif;
        }
        
        .loading-logo {
            font-size: 48px;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .loading-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 30px;
            color: #FFB84D;
        }
        
        .progress-container {
            width: 400px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
        }
        
        .progress-text {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .loading-status {
            font-size: 14px;
            color: #ccc;
            min-height: 20px;
            animation: loadingDots 1.5s infinite;
        }
        
        @keyframes loadingDots {
            0% { opacity: 0.4; }
            50% { opacity: 1; }
            100% { opacity: 0.4; }
        }
        
        .loading-tips {
            margin-top: 30px;
            text-align: center;
            font-size: 12px;
            color: #aaa;
            max-width: 300px;
        }
        
        /* Speed Control Bar */
        .speed-control {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 15px;
            min-width: 200px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 99;
            transition: all 0.3s ease;
            transform: translateX(0);
        }
        
        .speed-control.collapsed {
            transform: translateX(calc(100% - 50px));
        }
        
        .speed-toggle {
            position: absolute;
            left: -15px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 165, 0, 0.9);
            color: white;
            border: none;
            padding: 8px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .speed-toggle:hover {
            background: rgba(255, 140, 0, 1);
            transform: translateY(-50%) scale(1.1);
        }
        
        .speed-header {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #FFB84D;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .speed-slider {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
            margin: 10px 0;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
        }
        
        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(45deg, #FF6B35, #FFB84D);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.5);
            transition: all 0.2s ease;
        }
        
        .speed-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(255, 107, 53, 0.8);
        }
        
        .speed-value {
            font-size: 12px;
            color: #ccc;
            text-align: center;
            margin-top: 5px;
        }
        
        .original-speed {
            font-size: 10px;
            color: #888;
            text-align: center;
            margin-top: 3px;
            font-style: italic;
        }
        
        /* Virtual Arrow Controls */
        .virtual-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: grid;
            grid-template-columns: repeat(3, 50px);
            grid-template-rows: repeat(3, 50px);
            gap: 5px;
            z-index: 98;
        }
        
        .virtual-arrow {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s ease;
            backdrop-filter: blur(5px);
            user-select: none;
        }
        
        .virtual-arrow:hover {
            background: rgba(255, 107, 53, 0.3);
            border-color: rgba(255, 107, 53, 0.8);
            transform: scale(1.05);
        }
        
        .virtual-arrow:active,
        .virtual-arrow.pressed {
            background: rgba(255, 107, 53, 0.8);
            border-color: rgba(255, 140, 0, 1);
            transform: scale(0.95);
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .virtual-arrow.empty {
            visibility: hidden;
        }
        
        /* Ultra High Frame Rate Indicator */
        .fps-counter {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 8px 12px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border: 1px solid rgba(0, 255, 0, 0.3);
            z-index: 100;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-logo">üê±üèôÔ∏è</div>
        <div class="loading-title">Whiskers' NYC Adventure</div>
        <div class="progress-container">
            <div class="progress-bar" id="progressBar"></div>
        </div>
        <div class="progress-text" id="progressText">0%</div>
        <div class="loading-status" id="loadingStatus">Initializing game...</div>
        <div class="loading-tips">
            üí° Use WASD to move Whiskers around the city<br>
            üéØ Find glowing treasures to win the game<br>
            ‚öôÔ∏è Check settings for hints and customization
        </div>
    </div>
    
    <div id="msg">üê± Whiskers prowls the bright New York streets... Use WASD or Arrow Keys to explore! üèôÔ∏è</div>
    <div id="controls">Controls: WASD or Arrow Keys to move Whiskers ‚Ä¢ Find glowing spots in the city! üåü</div>
    
    <!-- FPS Counter -->
    <div class="fps-counter" id="fpsCounter">FPS: 9000000</div>
    
    <!-- Settings Button -->
    <button class="settings-btn" onclick="toggleSettings()">‚öôÔ∏è</button>
    
    <!-- Speed Control Bar -->
    <div class="speed-control" id="speedControl">
        <button class="speed-toggle" onclick="toggleSpeedControl()">üèÉ</button>
        <div class="speed-header">
            <span>üêæ Whiskers Speed</span>
        </div>
        <input type="range" class="speed-slider" id="speedSlider" min="0.01" max="2" step="0.01" value="0.1">
        <div class="speed-value" id="speedValue">Normal (0.10)</div>
        <div class="original-speed" id="originalSpeed">Original Speed: Trotting (0.12)</div>
    </div>
    
    <!-- Virtual Arrow Controls -->
    <div class="virtual-controls" id="virtualControls">
        <div class="virtual-arrow empty"></div>
        <div class="virtual-arrow" data-key="w">‚Üë</div>
        <div class="virtual-arrow empty"></div>
        <div class="virtual-arrow" data-key="a">‚Üê</div>
        <div class="virtual-arrow" data-key="s">‚Üì</div>
        <div class="virtual-arrow" data-key="d">‚Üí</div>
        <div class="virtual-arrow empty"></div>
        <div class="virtual-arrow empty"></div>
        <div class="virtual-arrow empty"></div>
    </div>
    
    <!-- Settings Panel -->
    <div class="settings-panel" id="settingsPanel">
        <div class="settings-header">üéÆ Game Settings</div>
        
        <div class="setting-row">
            <span class="setting-label">üß≠ Hint Arrows</span>
            <div class="toggle-switch" id="hintsToggle" onclick="toggleHints()"></div>
        </div>
        
        <div class="setting-row">
            <span class="setting-label">üéµ Sound Effects</span>
            <div class="toggle-switch" id="soundToggle" onclick="toggleSound()"></div>
        </div>
        
        <div class="setting-row">
            <span class="setting-label">üêæ Paw Prints</span>
            <div class="toggle-switch active" id="pawsToggle" onclick="togglePawPrints()"></div>
        </div>
        
        <div class="setting-row">
            <span class="setting-label">‚ôæÔ∏è Never Remove Paw Prints</span>
            <div class="toggle-switch" id="permanentPawsToggle" onclick="togglePermanentPawPrints()"></div>
        </div>
        
        <div class="setting-row">
            <span class="setting-label">‚ùÑÔ∏è Snow on Ground</span>
            <div class="toggle-switch active" id="snowToggle" onclick="toggleSnow()"></div>
        </div>
        
        <div class="setting-row">
            <span class="setting-label">‚ú® Particles</span>
            <div class="toggle-switch active" id="particlesToggle" onclick="toggleParticles()"></div>
        </div>
        
        <div class="setting-row">
            <span class="setting-label">üì∑ Auto Camera</span>
            <div class="toggle-switch active" id="cameraToggle" onclick="toggleAutoCamera()"></div>
        </div>
        
        <div class="setting-row">
            <span class="setting-label">üåü Enhanced Graphics</span>
            <div class="toggle-switch active" id="graphicsToggle" onclick="toggleGraphics()"></div>
        </div>
        
        <div class="setting-row">
            <span class="setting-label">üéØ Show Objectives</span>
            <div class="toggle-switch active" id="objectivesToggle" onclick="toggleObjectives()"></div>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
    <script>
        // Loading System
        let loadingProgress = 0;
        let isGameLoaded = false;
        const loadingSteps = [
            'Initializing Three.js engine...',
            'Creating NYC skyline...',
            'Spawning Whiskers the cat...',
            'Setting up street lighting...',
            'Placing city treasures...',
            'Adding magical particles...',
            'Configuring game settings...',
            'Loading sound system...',
            'Finalizing game world...',
            'Ready to play!'
        ];
        
        function updateLoadingProgress(step, percentage) {
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const loadingStatus = document.getElementById('loadingStatus');
            
            loadingProgress = percentage;
            progressBar.style.width = percentage + '%';
            progressText.textContent = Math.round(percentage) + '%';
            loadingStatus.textContent = loadingSteps[step] || 'Loading...';
        }
        
        function hideLoadingScreen() {
            const loadingScreen = document.getElementById('loadingScreen');
            loadingScreen.style.opacity = '0';
            loadingScreen.style.transition = 'opacity 0.5s ease';
            setTimeout(() => {
                loadingScreen.style.display = 'none';
                isGameLoaded = true;
            }, 500);
        }
        
        // Start loading simulation
        function startLoading() {
            let currentStep = 0;
            const totalSteps = loadingSteps.length;
            const stepDuration = 400; // 400ms per step = ~4 seconds total
            
            const loadingInterval = setInterval(() => {
                const progress = ((currentStep + 1) / totalSteps) * 100;
                updateLoadingProgress(currentStep, progress);
                currentStep++;
                
                if (currentStep >= totalSteps) {
                    clearInterval(loadingInterval);
                    setTimeout(() => {
                        hideLoadingScreen();
                        initializeGame();
                    }, 200);
                }
            }, stepDuration);
        }
        
        // Initialize game after loading
        function initializeGame() {
            // Show welcome notification
            setTimeout(() => {
                showNotification('üéÆ Welcome to NYC! Press ‚öôÔ∏è for settings!');
            }, 1000);
        }
        
        // Start loading immediately
        startLoading();
        
        const d = document;
        const c = d.getElementById("msg");
        const s = new THREE.Scene();
        const cam = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
        const r = new THREE.WebGLRenderer({ antialias: true });
        
        r.setSize(innerWidth, innerHeight);
        d.body.appendChild(r.domElement);
        
        // Batch create all geometries and materials for faster loading
        const geometries = {
            plane: new THREE.PlaneGeometry(200, 200),
            streetLine: new THREE.PlaneGeometry(2, 200),
            building: new THREE.BoxGeometry(1, 1, 1), // Will be scaled
            window: new THREE.PlaneGeometry(0.5, 0.5),
            lampPost: new THREE.CylinderGeometry(0.1, 0.1, 8),
            lampGlow: new THREE.SphereGeometry(0.5),
            catBody: new THREE.BoxGeometry(1.2, 0.6, 0.8),
            catHead: new THREE.SphereGeometry(0.4, 16, 16),
            catEar: new THREE.ConeGeometry(0.15, 0.3, 8),
            catTail: new THREE.CylinderGeometry(0.05, 0.1, 1, 8),
            catEye: new THREE.SphereGeometry(0.06, 8, 8),
            catLeg: new THREE.CylinderGeometry(0.08, 0.1, 0.4, 8),
            treasure: new THREE.CircleGeometry(1.5, 16),
            orbiter: new THREE.SphereGeometry(0.05),
            metro: new THREE.BoxGeometry(6, 2, 2),
            pawPrint: new THREE.CircleGeometry(0.15, 8),
            snowFlake: new THREE.CircleGeometry(0.05, 6),
            snowPile: new THREE.SphereGeometry(0.2, 8, 6)
        };
        
        const materials = {
            ground: new THREE.MeshPhongMaterial({ color: 0x666666, shininess: 10, specular: 0x333333 }),
            streetLine: new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.8 }),
            building: new THREE.MeshLambertMaterial({ color: 0x8B7355 }), // Will be modified per building
            window: new THREE.MeshBasicMaterial({ color: 0xFFFF88, emissive: 0x444422, transparent: true, opacity: 0.8 }),
            lampPost: new THREE.MeshLambertMaterial({ color: 0x333333 }),
            lampGlow: new THREE.MeshBasicMaterial({ color: 0xFFAA44, emissive: 0x664422, transparent: true, opacity: 0.6 }),
            catParts: new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6, metalness: 0.1, emissive: 0x111111 }),
            catEyes: new THREE.MeshBasicMaterial({ color: 0x00ff88, emissive: 0x004422 }),
            treasure: new THREE.MeshBasicMaterial({ color: 0xFFAA33, opacity: 0.8, transparent: true, emissive: 0x884422 }),
            orbiter: new THREE.MeshBasicMaterial({ color: 0xFFBB44, emissive: 0x663322 }),
            metro: new THREE.MeshLambertMaterial({ color: 0x4169E1, emissive: 0x112244 }),
            pawPrint: new THREE.MeshBasicMaterial({ color: 0x333333, opacity: 0.7, transparent: true }),
            snow: new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.9 }),
            snowPile: new THREE.MeshLambertMaterial({ color: 0xF0F8FF, emissive: 0x222244 })
        };
        
        // Lighting - New York City lighting
        s.add(new THREE.AmbientLight(0xFFDDAA, 0.8)); // Warm city ambient light
        
        // Main street light
        const L = new THREE.PointLight(0xFFAA44, 3, 120);
        L.position.set(5, 25, 5);
        L.castShadow = true;
        s.add(L);
        
        // Street lighting - 80% intensity
        const streetLight1 = new THREE.DirectionalLight(0xFFBB66, 0.8);
        streetLight1.position.set(15, 30, 15);
        streetLight1.target.position.set(0, -1, 0);
        streetLight1.castShadow = true;
        s.add(streetLight1);
        s.add(streetLight1.target);
        
        const streetLight2 = new THREE.DirectionalLight(0xFFCC77, 0.8);
        streetLight2.position.set(-15, 30, -15);
        streetLight2.target.position.set(0, -1, 0);
        s.add(streetLight2);
        s.add(streetLight2.target);
        
        // City skyline lighting
        const skylineLight = new THREE.HemisphereLight(0xFFEECC, 0x444455, 0.7);
        s.add(skylineLight);
        
        // Add some neon-style accent lighting
        const neonLight1 = new THREE.PointLight(0xFF3366, 0.5, 50);
        neonLight1.position.set(20, 5, 20);
        s.add(neonLight1);
        
        const neonLight2 = new THREE.PointLight(0x3366FF, 0.5, 50);
        neonLight2.position.set(-20, 5, -20);
        s.add(neonLight2);
        
        // Ground - New York Street
        const g = new THREE.Mesh(geometries.plane, materials.ground);
        g.rotation.x = -Math.PI / 2;
        g.position.y = -1;
        s.add(g);
        
        // Add street lines (batch create)
        const streetLines = [];
        for (let i = -100; i <= 100; i += 20) {
            const line = new THREE.Mesh(geometries.streetLine, materials.streetLine);
            line.rotation.x = -Math.PI / 2;
            line.position.set(i, -0.99, 0);
            s.add(line);
            streetLines.push(line);
        }
        
        // Add snow on the ground (scattered snow piles and flakes)
        const snowElements = [];
        
        // Snow piles scattered around
        for (let i = 0; i < 100; i++) {
            const snowPile = new THREE.Mesh(geometries.snowPile, materials.snowPile);
            snowPile.position.set(
                (Math.random() - 0.5) * 180,
                -0.8 + Math.random() * 0.2,
                (Math.random() - 0.5) * 180
            );
            snowPile.scale.set(
                0.5 + Math.random() * 1.5,
                0.3 + Math.random() * 0.7,
                0.5 + Math.random() * 1.5
            );
            s.add(snowPile);
            snowElements.push(snowPile);
        }
        
        // Scattered snow flakes on ground
        for (let i = 0; i < 200; i++) {
            const snowFlake = new THREE.Mesh(geometries.snowFlake, materials.snow);
            snowFlake.rotation.x = -Math.PI / 2;
            snowFlake.position.set(
                (Math.random() - 0.5) * 190,
                -0.97,
                (Math.random() - 0.5) * 190
            );
            snowFlake.scale.set(
                0.5 + Math.random() * 2,
                0.5 + Math.random() * 2,
                1
            );
            s.add(snowFlake);
            snowElements.push(snowFlake);
        }
        
        // Create New York buildings (optimized)
        const buildings = [];
        for (let i = 0; i < 50; i++) {
            const height = 5 + Math.random() * 25;
            const width = 3 + Math.random() * 8;
            const depth = 3 + Math.random() * 8;
            
            // Clone and scale building geometry
            const buildingMaterial = materials.building.clone();
            buildingMaterial.color.setHSL(0.1, 0.2, 0.4 + Math.random() * 0.3);
            
            const building = new THREE.Mesh(geometries.building, buildingMaterial);
            building.scale.set(width, height, depth);
            
            // Position buildings around the perimeter
            const angle = (i / 50) * Math.PI * 2;
            const radius = 60 + Math.random() * 40;
            building.position.set(
                Math.cos(angle) * radius,
                height / 2,
                Math.sin(angle) * radius
            );
            
            s.add(building);
            buildings.push(building);
            
            // Add windows to buildings (optimized)
            const windowsPerFloor = Math.floor(width / 2);
            const floors = Math.floor(height / 3);
            
            for (let floor = 0; floor < floors; floor++) {
                for (let window = 0; window < windowsPerFloor; window++) {
                    if (Math.random() > 0.3) { // 70% chance of lit window
                        const windowLight = new THREE.Mesh(geometries.window, materials.window);
                        windowLight.position.set(
                            building.position.x + (window - windowsPerFloor/2) * 2,
                            building.position.y - height/2 + (floor + 0.5) * 3,
                            building.position.z + depth/2 + 0.1
                        );
                        s.add(windowLight);
                    }
                }
            }
        }
        
        // Add street lamps (optimized)
        for (let i = -80; i <= 80; i += 25) {
            for (let j = -80; j <= 80; j += 25) {
                if (Math.abs(i) > 20 || Math.abs(j) > 20) { // Don't place in center play area
                    const lampPost = new THREE.Mesh(geometries.lampPost, materials.lampPost);
                    lampPost.position.set(i, 4, j);
                    s.add(lampPost);
                    
                    const lampLight = new THREE.PointLight(0xFFAA44, 1, 15);
                    lampLight.position.set(i, 8, j);
                    s.add(lampLight);
                    
                    const lampGlow = new THREE.Mesh(geometries.lampGlow, materials.lampGlow);
                    lampGlow.position.set(i, 8, j);
                    s.add(lampGlow);
                }
            }
        }
        
        // Player (Whiskers) - Black Cat (optimized)
        const catGroup = new THREE.Group();
        
        // Cat body
        const catBody = new THREE.Mesh(geometries.catBody, materials.catParts);
        catBody.position.y = 0.3;
        
        // Cat head
        const catHead = new THREE.Mesh(geometries.catHead, materials.catParts);
        catHead.position.set(0, 0.7, 0.5);
        
        // Cat ears
        const leftEar = new THREE.Mesh(geometries.catEar, materials.catParts);
        leftEar.position.set(-0.2, 0.95, 0.4);
        
        const rightEar = new THREE.Mesh(geometries.catEar, materials.catParts);
        rightEar.position.set(0.2, 0.95, 0.4);
        
        // Cat tail
        const catTail = new THREE.Mesh(geometries.catTail, materials.catParts);
        catTail.position.set(0, 0.5, -0.7);
        catTail.rotation.x = Math.PI / 4;
        
        // Cat eyes (glowing)
        const leftEye = new THREE.Mesh(geometries.catEye, materials.catEyes);
        leftEye.position.set(-0.15, 0.75, 0.75);
        
        const rightEye = new THREE.Mesh(geometries.catEye, materials.catEyes);
        rightEye.position.set(0.15, 0.75, 0.75);
        
        // Cat legs
        const frontLeftLeg = new THREE.Mesh(geometries.catLeg, materials.catParts);
        frontLeftLeg.position.set(-0.3, 0.1, 0.3);
        
        const frontRightLeg = new THREE.Mesh(geometries.catLeg, materials.catParts);
        frontRightLeg.position.set(0.3, 0.1, 0.3);
        
        const backLeftLeg = new THREE.Mesh(geometries.catLeg, materials.catParts);
        backLeftLeg.position.set(-0.3, 0.1, -0.1);
        
        const backRightLeg = new THREE.Mesh(geometries.catLeg, materials.catParts);
        backRightLeg.position.set(0.3, 0.1, -0.1);
        
        // Add all parts to cat group
        catGroup.add(catBody, catHead, leftEar, rightEar, catTail, leftEye, rightEye, frontLeftLeg, frontRightLeg, backLeftLeg, backRightLeg);
        
        // Position the cat group
        catGroup.position.y = 0.2;
        
        // Use catGroup as our player object (w)
        const w = catGroup;
        s.add(w);
        
        // Magic treasures (optimized)
        const spots = [];
        const goal = 3;
        let found = 0;
        
        for (let i = 0; i < goal; i++) {
            const sp = new THREE.Mesh(geometries.treasure, materials.treasure);
            sp.rotation.x = -Math.PI / 2;
            sp.position.set(
                Math.random() * 40 - 20,
                -0.99,
                Math.random() * 40 - 20
            );
            s.add(sp);
            spots.push(sp);
        }
        
        // Floating city particles (optimized batch creation)
        const FG = new THREE.BufferGeometry();
        const FN = 300;
        const fp = new Float32Array(FN * 3); // Pre-allocate array
        
        for (let i = 0; i < FN * 3; i += 3) {
            fp[i] = (Math.random() - 0.5) * 60;     // x
            fp[i + 1] = Math.random() * 15;         // y
            fp[i + 2] = (Math.random() - 0.5) * 60; // z
        }
        
        FG.setAttribute("position", new THREE.Float32BufferAttribute(fp, 3));
        const fs = new THREE.Points(
            FG,
            new THREE.PointsMaterial({
                color: 0xFFDD88,
                size: 0.2,
                transparent: true,
                opacity: 0.6
            })
        );
        s.add(fs);
        
        // Orbiters around player (optimized)
        const orbiters = [];
        const orbData = [];
        
        for (let i = 0; i < 30; i++) {
            const o = new THREE.Mesh(geometries.orbiter, materials.orbiter);
            s.add(o);
            orbiters.push(o);
            orbData.push({
                r: 1 + Math.random() * 2,
                a: Math.random() * 2 * Math.PI,
                s: 0.3 + Math.random() * 0.7
            });
        }
        
        // NYC Subway Train (optimized)
        const metro = new THREE.Mesh(geometries.metro, materials.metro);
        metro.position.set(0, -0.5, 50);
        metro.visible = false;
        s.add(metro);
        
        // Camera setup
        cam.position.set(5, 4, 7);
        cam.lookAt(w.position);
        
        // Game settings
        let gameSettings = {
            hintsEnabled: false,
            soundEnabled: false,
            pawPrintsEnabled: true,
            permanentPawPrintsEnabled: false,
            snowEnabled: true,
            particlesEnabled: true,
            autoCameraEnabled: true,
            graphicsEnabled: true,
            objectivesEnabled: true
        };
        
        // Speed control variables
        let catSpeed = 0.1;
        let speedControlCollapsed = false;
        
        // Virtual controls state
        let virtualKeys = {};
        
        // Ultra high FPS counter
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 9000000; // Target ultra-high FPS display
        
        // Hint arrows array
        const hintArrows = [];
        
        function createHintArrow(targetPosition, type = 'treasure') {
            const arrow = document.createElement('div');
            arrow.className = 'hint-arrow';
            arrow.style.position = 'absolute';
            document.body.appendChild(arrow);
            
            // Make arrow 30% bigger
            arrow.style.transform = 'scale(1.3)';
            
            return {
                element: arrow,
                target: targetPosition,
                type: type
            };
        }
        
        function updateHintArrows() {
            if (!gameSettings.hintsEnabled) {
                hintArrows.forEach(arrow => {
                    if (arrow.element && arrow.element.parentNode) {
                        arrow.element.remove();
                    }
                });
                hintArrows.length = 0;
                return;
            }
            
            // Clear existing arrows
            hintArrows.forEach(arrow => {
                if (arrow.element && arrow.element.parentNode) {
                    arrow.element.remove();
                }
            });
            hintArrows.length = 0;
            
            // Create arrows for visible treasures
            spots.forEach(spot => {
                if (spot.visible) {
                    const arrow = createHintArrow(spot.position, 'treasure');
                    hintArrows.push(arrow);
                }
            });
            
            // Create arrow for metro if visible
            if (metro.visible) {
                const arrow = createHintArrow(metro.position, 'metro');
                hintArrows.push(arrow);
            }
        }
        
        function updateArrowPositions() {
            hintArrows.forEach(arrow => {
                const screenPos = getScreenPosition(arrow.target);
                if (screenPos) {
                    const centerX = window.innerWidth / 2;
                    const centerY = window.innerHeight / 2;
                    
                    const dx = screenPos.x - centerX;
                    const dy = screenPos.y - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 100) { // Only show arrows for distant targets
                        const angle = Math.atan2(dy, dx);
                        const arrowDistance = Math.min(200, distance * 0.8);
                        
                        const arrowX = centerX + Math.cos(angle) * arrowDistance;
                        const arrowY = centerY + Math.sin(angle) * arrowDistance;
                        
                        arrow.element.style.left = arrowX + 'px';
                        arrow.element.style.top = arrowY + 'px';
                        arrow.element.style.transform = `scale(1.3) rotate(${angle + Math.PI/2}rad)`;
                        arrow.element.style.display = 'block';
                    } else {
                        arrow.element.style.display = 'none';
                    }
                }
            });
        }
        
        function getScreenPosition(worldPosition) {
            const vector = worldPosition.clone();
            vector.project(cam);
            
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (vector.y * -0.5 + 0.5) * window.innerHeight;
            
            return { x: x, y: y };
        }
        
        // Paw prints array
        const pawPrints = [];
        let lastPawPrintPosition = new THREE.Vector3();
        
        function addPawPrint(position) {
            // Only limit paw prints if permanent mode is disabled
            if (!gameSettings.permanentPawPrintsEnabled && pawPrints.length > 20) {
                // Remove oldest paw print
                const oldPrint = pawPrints.shift();
                s.remove(oldPrint);
            }
            
            const pawPrint = new THREE.Mesh(
                geometries.pawPrint,
                materials.pawPrint.clone()
            );
            pawPrint.rotation.x = -Math.PI / 2;
            pawPrint.position.set(position.x, -0.98, position.z);
            s.add(pawPrint);
            pawPrints.push(pawPrint);
            
            // Only fade out paw prints if permanent mode is disabled
            if (!gameSettings.permanentPawPrintsEnabled) {
                setTimeout(() => {
                    const fadeOut = setInterval(() => {
                        if (pawPrint.material.opacity > 0) {
                            pawPrint.material.opacity -= 0.05;
                        } else {
                            clearInterval(fadeOut);
                        }
                    }, 100);
                }, 2000);
            }
        }
        
        // Keyboard controls
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });
        
        function updatePlayer() {
            let isMoving = false;
            const oldPosition = w.position.clone();

            // Check both keyboard and virtual controls
            const isUpPressed = keys['w'] || keys['arrowup'] || virtualKeys['w'];
            const isDownPressed = keys['s'] || keys['arrowdown'] || virtualKeys['s'];
            const isLeftPressed = keys['a'] || keys['arrowleft'] || virtualKeys['a'];
            const isRightPressed = keys['d'] || keys['arrowright'] || virtualKeys['d'];

            // Movement controls with fixed speed (never increases by holding key)
            if (isUpPressed) {
                w.position.z -= catSpeed;
                isMoving = true;
            }
            if (isDownPressed) {
                w.position.z += catSpeed;
                isMoving = true;
            }
            if (isLeftPressed) {
                w.position.x -= catSpeed;
                isMoving = true;
            }
            if (isRightPressed) {
                w.position.x += catSpeed;
                isMoving = true;
            }

            // Add paw prints when moving (if enabled)
            if (isMoving && gameSettings.pawPrintsEnabled && w.position.distanceTo(lastPawPrintPosition) > 1) {
                addPawPrint(w.position);
                lastPawPrintPosition.copy(w.position);
            }

            // Cat walking animation with speed-based intensity
            if (isMoving) {
                // Animation intensity only depends on catSpeed from slider
                const animationIntensity = Math.min(catSpeed * 10, 2);
                w.position.y = 0.2 + Math.sin(Date.now() * 0.01 * animationIntensity) * 0.05 * animationIntensity;

                // Tail swishing faster at higher speeds
                const tail = w.children.find(child => child.geometry && child.geometry.type === 'CylinderGeometry' && child.position.z < 0);
                if (tail) {
                    tail.rotation.z = Math.sin(Date.now() * 0.008 * animationIntensity) * 0.3;
                }

                // Ear twitching faster at higher speeds
                const ears = w.children.filter(child => child.geometry && child.geometry.type === 'ConeGeometry');
                ears.forEach((ear, index) => {
                    ear.rotation.z = Math.sin(Date.now() * 0.012 * animationIntensity + index) * 0.1;
                });
            } else {
                // Reset to idle position
                w.position.y = 0.2;
            }
            
            // Update camera to follow player (if auto camera enabled)
            if (gameSettings.autoCameraEnabled) {
                cam.position.x = w.position.x + 5;
                cam.position.z = w.position.z + 7;
                cam.lookAt(w.position);
            }
        }
        
        // Settings functions
        function toggleSettings() {
            const panel = document.getElementById('settingsPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }
        
        function toggleHints() {
            gameSettings.hintsEnabled = !gameSettings.hintsEnabled;
            document.getElementById('hintsToggle').classList.toggle('active');
            updateHintArrows();
            showNotification(gameSettings.hintsEnabled ? 'üß≠ Hint arrows enabled!' : 'üö´ Hint arrows disabled');
        }
        
        function toggleSound() {
            gameSettings.soundEnabled = !gameSettings.soundEnabled;
            document.getElementById('soundToggle').classList.toggle('active');
            showNotification(gameSettings.soundEnabled ? 'üéµ Sound effects enabled!' : 'üîá Sound effects disabled');
        }
        
        function togglePawPrints() {
            gameSettings.pawPrintsEnabled = !gameSettings.pawPrintsEnabled;
            document.getElementById('pawsToggle').classList.toggle('active');
            if (!gameSettings.pawPrintsEnabled) {
                // Clear existing paw prints
                pawPrints.forEach(print => s.remove(print));
                pawPrints.length = 0;
            }
            showNotification(gameSettings.pawPrintsEnabled ? 'üêæ Paw prints enabled!' : 'üö´ Paw prints disabled');
        }
        
        function togglePermanentPawPrints() {
            gameSettings.permanentPawPrintsEnabled = !gameSettings.permanentPawPrintsEnabled;
            document.getElementById('permanentPawsToggle').classList.toggle('active');
            
            if (gameSettings.permanentPawPrintsEnabled) {
                // Make all existing paw prints fully opaque and permanent
                pawPrints.forEach(print => {
                    print.material.opacity = 0.7;
                });
                showNotification('‚ôæÔ∏è Paw prints will never fade away!');
            } else {
                showNotification('‚è∞ Paw prints will fade over time');
            }
        }
        
        function toggleSnow() {
            gameSettings.snowEnabled = !gameSettings.snowEnabled;
            document.getElementById('snowToggle').classList.toggle('active');
            
            // Toggle snow visibility
            snowElements.forEach(element => {
                element.visible = gameSettings.snowEnabled;
            });
            
            showNotification(gameSettings.snowEnabled ? '‚ùÑÔ∏è Snow enabled!' : 'üö´ Snow disabled');
        }
        
        function toggleParticles() {
            gameSettings.particlesEnabled = !gameSettings.particlesEnabled;
            document.getElementById('particlesToggle').classList.toggle('active');
            fs.visible = gameSettings.particlesEnabled;
            showNotification(gameSettings.particlesEnabled ? '‚ú® Particles enabled!' : 'üö´ Particles disabled');
        }
        
        function toggleAutoCamera() {
            gameSettings.autoCameraEnabled = !gameSettings.autoCameraEnabled;
            document.getElementById('cameraToggle').classList.toggle('active');
            showNotification(gameSettings.autoCameraEnabled ? 'üì∑ Auto camera enabled!' : 'üéÆ Manual camera mode');
        }
        
        function toggleGraphics() {
            gameSettings.graphicsEnabled = !gameSettings.graphicsEnabled;
            document.getElementById('graphicsToggle').classList.toggle('active');
            
            // Toggle graphics quality
            orbiters.forEach(orbiter => {
                orbiter.visible = gameSettings.graphicsEnabled;
            });
            
            showNotification(gameSettings.graphicsEnabled ? 'üåü Enhanced graphics enabled!' : '‚ö° Performance mode enabled');
        }
        
        function toggleObjectives() {
            gameSettings.objectivesEnabled = !gameSettings.objectivesEnabled;
            document.getElementById('objectivesToggle').classList.toggle('active');
            
            // Toggle objective visibility
            spots.forEach(spot => {
                if (gameSettings.objectivesEnabled) {
                    spot.material.opacity = 0.8;
                } else {
                    spot.material.opacity = 0.3;
                }
            });
            
            showNotification(gameSettings.objectivesEnabled ? 'üéØ Objectives highlighted!' : 'üëÅÔ∏è Objectives dimmed');
        }
        
        function showNotification(message) {
            // Remove existing notification
            const existingNotification = document.querySelector('.notification');
            if (existingNotification) {
                existingNotification.remove();
            }

            // Create notification
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.innerHTML = message;
            notification.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                background: rgba(0, 0, 0, 0.9);
                color: white;
                padding: 12px 20px;
                border-radius: 25px;
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.2);
                z-index: 10000;
                transform: translateX(300px);
                transition: all 0.3s ease;
                font-size: 14px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            `;

            document.body.appendChild(notification);

            // Animate in
            setTimeout(() => {
                notification.style.transform = 'translateX(0)';
            }, 100);

            // Remove after delay
            setTimeout(() => {
                notification.style.transform = 'translateX(300px)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.remove();
                    }
                }, 300);
            }, 3000);
        }
        
        // Speed Control Functions
        function toggleSpeedControl() {
            speedControlCollapsed = !speedControlCollapsed;
            const speedControl = document.getElementById('speedControl');
            speedControl.classList.toggle('collapsed', speedControlCollapsed);
            
            const toggleBtn = speedControl.querySelector('.speed-toggle');
            toggleBtn.textContent = speedControlCollapsed ? 'üèÉ' : 'üêæ';
        }
        
        function initializeSpeedControl() {
            const speedSlider = document.getElementById('speedSlider');
            const speedValue = document.getElementById('speedValue');
            
            speedSlider.addEventListener('input', (e) => {
                catSpeed = parseFloat(e.target.value);
                updateSpeedDisplay();
                
                // Show speed change notification
                const speedText = getSpeedText(catSpeed);
                showNotification(`üêæ Whiskers is now ${speedText}!`);
            });
            
            updateSpeedDisplay();
        }
        
        function updateSpeedDisplay() {
            const speedValue = document.getElementById('speedValue');
            const speedText = getSpeedText(catSpeed);
            speedValue.textContent = `${speedText} (${catSpeed.toFixed(2)})`;
        }
        
        function getSpeedText(speed) {
            if (speed <= 0.05) return "Sneaking";
            if (speed <= 0.1) return "Normal";
            if (speed <= 0.3) return "Trotting";
            if (speed <= 0.6) return "Running";
            if (speed <= 1.0) return "Sprinting";
            if (speed <= 1.5) return "Super Speed";
            return "TURBO CAT";
        }
        
        // Virtual Controls Functions
        function pressVirtualKey(key) {
            virtualKeys[key] = true;
            const arrow = document.querySelector(`[data-key="${key}"]`);
            if (arrow) {
                arrow.classList.add('pressed');
            }
            
            // Haptic feedback simulation
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }
        }
        
        function releaseVirtualKey(key) {
            virtualKeys[key] = false;
            const arrow = document.querySelector(`[data-key="${key}"]`);
            if (arrow) {
                arrow.classList.remove('pressed');
            }
        }
        
        // Ultra FPS Counter Update
        function updateFPS() {
            frameCount++;
            const currentTime = performance.now();
            
            if (currentTime - lastTime >= 100) { // Update every 100ms
                // Simulate ultra-high FPS with some randomness
                fps = Math.floor(8000000 + Math.random() * 2000000);
                document.getElementById('fpsCounter').textContent = `FPS: ${fps.toLocaleString()}`;
                
                frameCount = 0;
                lastTime = currentTime;
            }
        }
        
        // Game loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update ultra FPS counter
            updateFPS();
            
            // Update player movement
            updatePlayer();
            
            // Update hint arrows
            if (gameSettings.hintsEnabled) {
                updateHintArrows();
                updateArrowPositions();
            }
            
            // Subtle cat head movement (looking around)
            const catHead = w.children.find(child => child.geometry && child.geometry.type === 'SphereGeometry');
            if (catHead) {
                catHead.rotation.y = Math.sin(Date.now() * 0.003) * 0.2;
            }
            
            // Update falling city particles (if enabled)
            if (gameSettings.particlesEnabled) {
                let p = FG.attributes.position.array;
                for (let i = 1; i < p.length; i += 3) {
                    p[i] -= 0.015; // Slower falling for city atmosphere
                    if (p[i] < -1) p[i] = 15;
                }
                FG.attributes.position.needsUpdate = true;
            }
            
            // Update orbiters (if graphics enabled)
            if (gameSettings.graphicsEnabled) {
                orbiters.forEach((o, i) => {
                    orbData[i].a += 0.02 * orbData[i].s;
                    o.position.set(
                        Math.cos(orbData[i].a) * orbData[i].r + w.position.x,
                        1.5,
                        Math.sin(orbData[i].a) * orbData[i].r + w.position.z
                    );
                });
            }
            
            // Check for spot collection
            spots.forEach((sp, i) => {
                if (sp.visible && w.position.distanceTo(sp.position) < 2) {
                    sp.visible = false;
                    found++;
                    c.innerText = `üêæ City treasure found! Whiskers purrs... (${found}/${goal}) - Keep exploring NYC! üèôÔ∏è`;
                    
                    // Play sound effect if enabled
                    if (gameSettings.soundEnabled) {
                        playSound('treasure');
                    }
                    
                    if (found === goal) {
                        c.innerText = "üê± *Purr* You hear rumbling... the subway arrives! Whiskers' ears perk up! üöá";
                        metro.visible = true;
                        updateHintArrows(); // Update arrows when metro appears
                        
                        if (gameSettings.soundEnabled) {
                            playSound('metro');
                        }
                    }
                }
            });
            
            // Check for metro boarding
            if (metro.visible && w.position.distanceTo(metro.position) < 3) {
                c.innerText = "üê± Whiskers gracefully leaps onto the NYC subway... Victory! *Meow* üéâ";
                w.visible = false;
                
                if (gameSettings.soundEnabled) {
                    playSound('victory');
                }
                
                // Add some celebration effects
                setTimeout(() => {
                    c.innerText = "üéâ PURR-FECT! Whiskers conquered the Big Apple! üêæ‚ú®üèôÔ∏è";
                }, 1000);
            }
            
            r.render(s, cam);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            cam.aspect = window.innerWidth / window.innerHeight;
            cam.updateProjectionMatrix();
            r.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Sound effects function
        function playSound(type) {
            if (!gameSettings.soundEnabled) return;
            
            // Create audio context for sound effects
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            switch(type) {
                case 'treasure':
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    break;
                case 'metro':
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.5);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    break;
                case 'victory':
                    oscillator.frequency.setValueAtTime(523, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(659, audioContext.currentTime + 0.1);
                    oscillator.frequency.setValueAtTime(784, audioContext.currentTime + 0.2);
                    oscillator.frequency.setValueAtTime(1047, audioContext.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                    break;
            }
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + (type === 'victory' ? 0.4 : type === 'metro' ? 0.5 : 0.2));
        }
        
        // Initialize settings on page load
        window.addEventListener('load', () => {
            // Close settings panel initially
            document.getElementById('settingsPanel').style.display = 'none';
            
            // Initialize hint arrows
            updateHintArrows();
            
            // Initialize speed control
            initializeSpeedControl();
            
            // Set initial toggle states
            document.getElementById('pawsToggle').classList.add('active');
            document.getElementById('snowToggle').classList.add('active');
            document.getElementById('particlesToggle').classList.add('active');
            document.getElementById('cameraToggle').classList.add('active');
            document.getElementById('graphicsToggle').classList.add('active');
            document.getElementById('objectivesToggle').classList.add('active');
            
            // Add touch event handlers for virtual controls
            document.querySelectorAll('.virtual-arrow').forEach(arrow => {
                // Prevent context menu on long press
                arrow.addEventListener('contextmenu', (e) => e.preventDefault());
                
                // Handle touch events
                arrow.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const key = arrow.getAttribute('data-key');
                    if (key) pressVirtualKey(key);
                });
                
                arrow.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const key = arrow.getAttribute('data-key');
                    if (key) releaseVirtualKey(key);
                });
                
                // Handle mouse events for desktop
                arrow.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    const key = arrow.getAttribute('data-key');
                    if (key) pressVirtualKey(key);
                });
                
                arrow.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    const key = arrow.getAttribute('data-key');
                    if (key) releaseVirtualKey(key);
                });
                
                arrow.addEventListener('mouseleave', (e) => {
                    const key = arrow.getAttribute('data-key');
                    if (key) releaseVirtualKey(key);
                });
            });
            
            // Complete loading and hide loading screen
            updateLoadingProgress("Game Ready!", 100);
            
            setTimeout(() => {
                const loading = document.querySelector('.loading-screen');
                if (loading) {
                    loading.style.opacity = '0';
                    setTimeout(() => {
                        loading.style.display = 'none';
                    }, 500);
                }
                
                // Show welcome notification with new features
                showNotification('‚ùÑÔ∏è NEW: Snow & permanent paw prints! Check settings!');
            }, 500);
        });
        
        // Start the game
        animate();
    </script>
</body>
</html>
