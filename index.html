<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Cat and Mouse Game</title>
    <style>
        html, body { height: 100%; margin: 0; padding: 0; }
        body { display: flex; justify-content: center; align-items: center; height: 100vh; background: #f0f0f0; }
        #gameContainer {
            position: relative;
            width: 90vw;
            max-width: 98vw;
            height: 90vw;
            max-height: 90vh;
            min-width: 320px;
            min-height: 320px;
            aspect-ratio: 1/1;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas { 
            background: #fff; 
            border: 2px solid #333; 
            width: 100%; 
            height: 100%; 
            display: block;
        }
        /* Expandable button and panel styles */
        #expandBtn, #expandBtnBR {
            position: absolute;
            left: 2vw;
            bottom: 2vw;
            z-index: 3;
            width: 8vw;
            min-width: 36px;
            max-width: 56px;
            height: 8vw;
            min-height: 36px;
            max-height: 56px;
            background: #fff;
            border: 2px solid #b8860b;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.2s;
        }
        #expandBtn:hover {
            background: #ffe4b5;
        }
        #expandPanel, #expandPanelBR {
            position: absolute;
            left: 2vw;
            bottom: 11vw;
            z-index: 3;
            min-width: 180px;
            max-width: 60vw;
            background: #fffbe8;
            border: 2px solid #b8860b;
            border-radius: 12px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.10);
            padding: 2vw 2vw 2vw 2vw;
            opacity: 0;
            pointer-events: none;
            transform: translateY(20px) scale(0.98);
            transition: opacity 0.25s, transform 0.25s;
        }
        #expandPanel.open, #expandPanelBR.open {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0) scale(1);
        }
        /* Responsive buttons */
        #startBtn, #stopBtn {
            font-size: 1.1em;
            padding: 0.5em 1.2em;
            border-radius: 0.7em;
            min-width: 80px;
        }
        #startBtn {
            position: absolute;
            top: 2vw;
            right: 2vw;
            z-index: 2;
        }
        #stopBtn {
            position: absolute;
            top: 2vw;
            left: 2vw;
            z-index: 2;
        }
        #levelDisplay {
            position: absolute;
            top: 2vw;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2;
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
            background: rgba(255,255,255,0.8);
            padding: 0.2em 1em;
            border-radius: 8px;
        }
        @media (max-width: 600px) {
            #gameContainer { min-width: 200px; min-height: 200px; }
            #expandPanel { min-width: 120px; padding: 3vw; }
            #expandBtn { min-width: 32px; min-height: 32px; }
        }
    </style>
</head>
<body>
<div id="gameContainer">
<button id="startBtn" style="background: #43a047; color: #fff; border: none;">Start Game</button>
<button id="stopBtn" style="background: #e53935; color: #fff; border: none;">Stop Game</button>
<div id="levelDisplay">Level: 1</div>
<!-- Expandable button and panel (Bottom Left) -->
<button id="expandBtn" title="Show settings" aria-label="Show settings">
    <svg id="settingsIcon" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="#b8860b" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="3.5"/>
        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 1 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 1 1 0-4h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06a1.65 1.65 0 0 0 1.82.33h.09A1.65 1.65 0 0 0 9 4.6V4a2 2 0 1 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82v.09a1.65 1.65 0 0 0 1.51 1H21a2 2 0 1 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"/>
    </svg>
</button>
<div id="expandPanel">
    <div style="font-weight:bold; color:#b8860b; margin-bottom:10px;">Settings</div>
    <div style="margin-bottom:12px;">
        <label for="catSpeedSlider" style="color:#333; font-size:1em;">Cat Speed: </label>
        <input id="catSpeedSlider" type="range" min="0.5" max="5" step="0.05" value="1.1" style="vertical-align:middle; width:110px;">
        <span id="catSpeedValue" style="color:#b8860b; font-weight:bold; margin-left:6px;">1.1</span>
    </div>
    <div style="margin-bottom:12px;">
        <label for="bgSwitch" style="color:#333; font-size:1em;">Wooden Floor Background: </label>
        <input id="bgSwitch" type="checkbox" checked style="vertical-align:middle;">
    </div>
    <div style="margin-bottom:12px;">
        <label for="levelTimeInput" style="color:#333; font-size:1em;">Level Time (sec): </label>
        <input id="levelTimeInput" type="number" min="3" max="60" step="1" value="3" style="vertical-align:middle; width:60px;">
    </div>
    <div style="margin-bottom:12px;">
        <label for="cheeseCountInput" style="color:#333; font-size:1em;">Max Cheese Pieces: </label>
        <input id="cheeseCountInput" type="number" min="1" max="10" step="1" value="3" style="vertical-align:middle; width:60px;">
    </div>
    <div style="margin-bottom:12px;">
        <label for="pipeCountInput" style="color:#333; font-size:1em;">Number of Pipes: </label>
        <input id="pipeCountInput" type="number" min="4" max="10" step="2" value="4" style="vertical-align:middle; width:60px;">
    </div>
    <div style="color:#333;">(Add your settings here)</div>
</div>
<!-- Expandable button and panel (Bottom Right) -->
<button id="expandBtnBR" title="Show superpowers" aria-label="Show superpowers" style="right:2vw; left:auto; bottom:2vw; position:absolute; z-index:3; width:8vw; min-width:36px; max-width:56px; height:8vw; min-height:36px; max-height:56px; background:#fff; border:2px solid #1976d2; border-radius:50%; box-shadow:0 2px 8px rgba(0,0,0,0.08); display:flex; align-items:center; justify-content:center; cursor:pointer; transition:background 0.2s;">
    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="#1976d2" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="10"/>
        <line x1="12" y1="8" x2="12" y2="12"/>
        <circle cx="12" cy="16" r="1.2"/>
    </svg>
</button>
<div id="expandPanelBR" style="right:2vw; left:auto; bottom:11vw; position:absolute; z-index:3; min-width:180px; max-width:60vw; background:#e3f2fd; border:2px solid #1976d2; border-radius:12px; box-shadow:0 2px 12px rgba(0,0,0,0.10); padding:2vw; opacity:0; pointer-events:none; transform:translateY(20px) scale(0.98); transition:opacity 0.25s, transform 0.25s;">
    <div style="font-weight:bold; color:#1976d2; margin-bottom:10px; display:flex; align-items:center; gap:8px;">
        Superpower Panel
        <span title="Boom!" style="font-size:1.5em; vertical-align:middle;">üí•</span>
    </div>
    <button id="freezeCatBtn" style="background:#1976d2; color:#fff; border:none; border-radius:8px; padding:0.5em 1.2em; font-size:1em; cursor:pointer; margin-bottom:6px;">Frezzer X</button>
    <button id="transparentMouseBtn" style="background:#1976d2; color:#fff; border:none; border-radius:8px; padding:0.5em 1.2em; font-size:1em; cursor:pointer; margin-bottom:6px;">Sight Suppressor II</button>
    <button id="addDogBtn" style="background:#ff9800; color:#fff; border:none; border-radius:8px; padding:0.5em 1.2em; font-size:1em; cursor:pointer; margin-bottom:6px;">Add Dog üê∂</button>
    <button id="add20MiceBtn" style="background:#43a047; color:#fff; border:none; border-radius:8px; padding:0.5em 1.2em; font-size:1em; cursor:pointer; margin-bottom:6px;">Mouse Divider XI üê≠</button>
    <div id="freezeCatStatus" style="color:#1976d2; font-weight:bold; margin-top:6px;"></div>
    <div id="transparentMouseStatus" style="color:#1976d2; font-weight:bold; margin-top:6px;"></div>
</div>
<canvas id="gameCanvas"></canvas>
</div>
<script>
// Responsive canvas sizing
const container = document.getElementById('gameContainer');
const canvas = document.getElementById('gameCanvas');
function resizeCanvas() {
    // Set canvas size to match container size
    const rect = container.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const ctx = canvas.getContext('2d');
let size = Math.max(32, Math.floor(canvas.width / 21)); // Responsive size for cat/mouse
const corners = [
    {x: 0, y: 0},
    {x: canvas.width - size, y: 0},
    {x: 0, y: canvas.height - size},
    {x: canvas.width - size, y: canvas.height - size}
];
let cat = { x: 230, y: 230, speed: 2 };
let mouse = { x: 100, y: 100 };
let running = false;
let level = 1;
let levelTimer = null;
let baseSpeed = 1.1;
let showYamYam = false;
let yamYamTimer = null;
let showBossLevel = false;
let bossLevelTimer = null;
let showBossLevel6 = false;
let bossLevel6Timer = null;
let grayCats = [];
let bossGrayCat = null;
let bossCatMinionCats = [];
let bossCatAddTimer = null;
let bossCat6 = null;
let isShaking = false;
let showWoodenFloor = true;
let mouseTransparent = false;
let mouseTransparentTimer = null;
let levelTime = 3; // Default level time in seconds
let cheeses = [];
let cheeseTimer = null;
let maxCheeseCount = 3;
let mouseScale = 1; // For mouse grow/shrink animation
let mouseScaleTarget = 1;
let mouseScaleAnimFrame = null;
let pipeCount = 4; // Default number of pipes (must be even, min 4)
let pipes = [];

// Mouse image
// const mouseImg = new Image();
// mouseImg.src = 'https://www.clipartmax.com/png/middle/30-303462_rat-icon-enviropest-mouse.png';

function drawTail(x, y, color, direction = 'right') {
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.beginPath();
    if (direction === 'right') {
        ctx.moveTo(x + size * 0.8, y + size * 0.7);
        ctx.bezierCurveTo(x + size * 1.2, y + size * 0.8, x + size * 1.3, y + size * 0.2, x + size * 1.1, y + size * 0.1);
    } else {
        ctx.moveTo(x + size * 0.2, y + size * 0.7);
        ctx.bezierCurveTo(x - size * 0.2, y + size * 0.8, x - size * 0.3, y + size * 0.2, x - size * 0.1, y + size * 0.1);
    }
    ctx.stroke();
    ctx.restore();
}

function drawMouseWithBody(x, y) {
    ctx.save();
    // Animate font size and vertical alignment
    ctx.font = `${Math.floor(size * mouseScale)}px serif`;
    ctx.fillText('üê≠', x, y + size * mouseScale);
    ctx.restore();
}

function drawCatWithBody(x, y) {
    // Draw tail
    drawTail(x, y, '#222', 'right');
    ctx.save();
    // Draw body (ellipse)
    ctx.beginPath();
    ctx.ellipse(x + size * 0.6, y + size * 0.7, size * 0.36, size * 0.23, -0.18, 0, 2 * Math.PI);
    ctx.fillStyle = '#444';
    ctx.shadowColor = '#222';
    ctx.shadowBlur = 5;
    ctx.fill();
    ctx.shadowBlur = 0;
    // Draw head (circle)
    ctx.beginPath();
    ctx.arc(x + size * 0.9, y + size * 0.7, size * 0.19, 0, 2 * Math.PI);
    ctx.fillStyle = '#444';
    ctx.fill();
    // Draw ears
    ctx.beginPath();
    ctx.moveTo(x + size * 1.01, y + size * 0.58);
    ctx.lineTo(x + size * 1.06, y + size * 0.48);
    ctx.lineTo(x + size * 0.97, y + size * 0.56);
    ctx.closePath();
    ctx.moveTo(x + size * 0.79, y + size * 0.58);
    ctx.lineTo(x + size * 0.74, y + size * 0.48);
    ctx.lineTo(x + size * 0.83, y + size * 0.56);
    ctx.closePath();
    ctx.fillStyle = '#444';
    ctx.fill();
    // Draw nose
    ctx.beginPath();
    ctx.arc(x + size * 0.97, y + size * 0.73, size * 0.04, 0, 2 * Math.PI);
    ctx.fillStyle = '#f8bb8f';
    ctx.fill();
    // Draw eyes
    ctx.beginPath();
    ctx.arc(x + size * 0.93, y + size * 0.68, size * 0.03, 0, 2 * Math.PI);
    ctx.arc(x + size * 0.87, y + size * 0.68, size * 0.03, 0, 2 * Math.PI);
    ctx.fillStyle = '#fff';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x + size * 0.93, y + size * 0.68, size * 0.015, 0, 2 * Math.PI);
    ctx.arc(x + size * 0.87, y + size * 0.68, size * 0.015, 0, 2 * Math.PI);
    ctx.fillStyle = '#222';
    ctx.fill();
    ctx.restore();
}

function drawWoodenFloor() {
    // Plank parameters
    const plankWidth = 120;
    const plankHeight = canvas.height;
    const plankCount = Math.ceil(canvas.width / plankWidth);
    for (let i = 0; i < plankCount; i++) {
        // Alternate plank colors for realism
        ctx.save();
        ctx.beginPath();
        ctx.rect(i * plankWidth, 0, plankWidth, plankHeight);
        ctx.fillStyle = i % 2 === 0 ? '#deb887' : '#d2a06d'; // Light/dark wood
        ctx.fill();
        // Draw plank edge
        ctx.strokeStyle = '#b8860b';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
    }
}

function draw() {
    // Always clear first
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Draw background based on switch
    if (showWoodenFloor) {
        drawWoodenFloor();
    } else {
        ctx.save();
        ctx.fillStyle = '#f0e4d7'; // Solid color background
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
    }
    // Canvas shake effect for level 6
    if (level === 6 && running) {
        isShaking = true;
        const shakeX = Math.round((Math.random() - 0.5) * 10); // -5 to +5 px
        const shakeY = Math.round((Math.random() - 0.5) * 10);
        canvas.style.transform = `translate(${shakeX}px, ${shakeY}px)`;
    } else if (isShaking) {
        isShaking = false;
        canvas.style.transform = '';
    }
    ctx.font = '36px serif';

    // --- LEVEL 10: Only cheese and dogs ---
    if (level === 10) {
        // Draw cheeses
        for (let cheese of cheeses) {
            ctx.save();
            ctx.font = `${Math.floor(size * 0.8)}px serif`;
            ctx.globalAlpha = 0.95;
            ctx.fillText('üßÄ', cheese.x, cheese.y + size * 0.7);
            ctx.globalAlpha = 1;
            ctx.restore();
        }
        // Draw dogs
        ctx.save();
        ctx.font = `${Math.floor(size * 0.9)}px serif`;
        for (let dog of dogs) {
            ctx.fillText('üê∂', dog.x, dog.y + size * 0.9);
        }
        ctx.restore();
        // Draw pipes
        ctx.save();
        for (let i = 0; i < pipes.length; i++) {
            const p = pipes[i];
            ctx.beginPath();
            ctx.arc(p.x, p.y, size * 0.6, 0, 2 * Math.PI);
            ctx.fillStyle = '#1976d2';
            ctx.globalAlpha = 0.7;
            ctx.fill();
            ctx.globalAlpha = 1;
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#0d47a1';
            ctx.stroke();
            ctx.font = 'bold 1em sans-serif';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.fillText(String.fromCharCode(65 + (i % 26)), p.x, p.y + 5);
        }
        ctx.restore();
        // Draw cat with body
        drawCatWithBody(cat.x, cat.y);
        // Draw cat emoji
        ctx.fillStyle = '#000';
        ctx.font = '36px serif';
        ctx.fillText('üê±', cat.x, cat.y + size);
        // Draw mouse with body
        drawMouseWithBody(mouse.x, mouse.y);
        // Draw yam-yam if needed
        if (showYamYam) {
            ctx.font = 'bold 24px sans-serif';
            ctx.fillStyle = '#e53935';
            ctx.fillText('–Ω—è–º-–Ω—è–º', cat.x + size, cat.y + size / 2);
            ctx.fillStyle = '#000';
        }
        return; // Do not draw anything else
    }

    // Draw boss gray cat if level 10
    if (level === 10 && bossGrayCat) {
        ctx.save();
        ctx.font = '180px serif'; // 36px * 5 = 180px
        ctx.globalAlpha = 0.8;
        ctx.fillStyle = '#888';
        ctx.fillText('üê±', bossGrayCat.x, bossGrayCat.y + 180); // Adjust for size
        ctx.globalAlpha = 1;
        // Draw BOSS CAT label below the boss cat
        ctx.font = 'bold 32px sans-serif';
        ctx.fillStyle = '#FFD600';
        ctx.textAlign = 'center';
        ctx.fillText('BOSS CAT', bossGrayCat.x + 90, bossGrayCat.y + 210);
        ctx.textAlign = 'start';
        ctx.restore();
        // Draw minion cats
        ctx.save();
        ctx.font = '36px serif';
        ctx.globalAlpha = 0.7;
        ctx.fillStyle = '#888';
        for (let minion of bossCatMinionCats) {
            ctx.fillText('üê±', minion.x, minion.y + size);
        }
        ctx.globalAlpha = 1;
        ctx.restore();
    }
    ctx.fillStyle = '#000';
    ctx.font = '36px serif';
    // Draw cat with body
    drawCatWithBody(cat.x, cat.y);
    // Draw mouse with body
    drawMouseWithBody(mouse.x, mouse.y);
    // Draw cat
    ctx.fillText('üê±', cat.x, cat.y + size);
    if (showYamYam) {
        ctx.font = 'bold 24px sans-serif';
        ctx.fillStyle = '#e53935';
        ctx.fillText('–Ω—è–º-–Ω—è–º', cat.x + size, cat.y + size / 2);
        ctx.fillStyle = '#000';
    }
    if (showBossLevel) {
        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = 1;
        ctx.font = 'bold 48px sans-serif';
        ctx.fillStyle = '#FFD600';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('BOSS LEVEL', canvas.width / 2, canvas.height / 2);
        ctx.textAlign = 'start';
        ctx.textBaseline = 'alphabetic';
        ctx.restore();
    }
    if (showBossLevel6) {
        ctx.save();
        ctx.globalAlpha = 0.98;
        ctx.fillStyle = '#e53935'; // Red background
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = 1;
        ctx.font = 'bold 64px sans-serif';
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('BOSS-LEVEL', canvas.width / 2, canvas.height / 2);
        ctx.textAlign = 'start';
        ctx.textBaseline = 'alphabetic';
        ctx.restore();
        return; // Don't draw game elements while message is shown
    }
    // Draw gray cats for level 6
    if (level >= 6 && level < 10 && grayCats.length > 0) {
        ctx.save();
        ctx.font = '36px serif';
        ctx.globalAlpha = 0.7;
        ctx.fillStyle = '#888';
        for (let gcat of grayCats) {
            ctx.fillText('üê±', gcat.x, gcat.y + size);
        }
        ctx.globalAlpha = 1;
        ctx.restore();
    }
    // Draw boss cat for level 6
    if (level >= 6 && level < 10 && bossCat6) {
        ctx.save();
        ctx.font = '180px serif'; // 36px * 5 = 180px
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = '#222';
        ctx.fillText('üê±', bossCat6.x, bossCat6.y + 180);
        ctx.globalAlpha = 1;
        ctx.font = 'bold 28px sans-serif';
        ctx.fillStyle = '#FFD600';
        ctx.textAlign = 'center';
        ctx.fillText('BOSS CAT', bossCat6.x + 90, bossCat6.y + 210);
        ctx.textAlign = 'start';
        ctx.restore();
    }
    // Draw cheeses
    for (let cheese of cheeses) {
        ctx.save();
        ctx.font = `${Math.floor(size * 0.8)}px serif`;
        ctx.globalAlpha = 0.95;
        ctx.fillText('üßÄ', cheese.x, cheese.y + size * 0.7);
        ctx.globalAlpha = 1;
        ctx.restore();
    }
}

// --- Dog logic ---
let dogs = [];
const addDogBtn = document.getElementById('addDogBtn');
if (addDogBtn) {
    addDogBtn.onclick = function() {
        // Add a dog at a random position with random direction and speed
        const margin = size;
        const x = Math.random() * (canvas.width - margin * 2) + margin;
        const y = Math.random() * (canvas.height - margin * 2) + margin;
        // Give each dog a random direction and speed (speed between 1 and 2)
        let angle = Math.random() * 2 * Math.PI;
        let speed = 1 + Math.random();
        dogs.push({ x, y, dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed, speed, bornLevel: level });
        draw();
    };
}
// Patch draw to render dogs
const originalDraw = draw;
draw = function() {
    originalDraw();
    // Draw dogs
    ctx.save();
    ctx.font = `${Math.floor(size * 0.9)}px serif`;
    for (let dog of dogs) {
        ctx.fillText('üê∂', dog.x, dog.y + size * 0.9);
    }
    ctx.restore();
}

// --- Extra mice logic ---
let extraMice = [];
const add20MiceBtn = document.getElementById('add20MiceBtn');
if (add20MiceBtn) {
    add20MiceBtn.onclick = function() {
        // Add 20 mice at random positions
        extraMice = [];
        for (let i = 0; i < 20; i++) {
            const margin = size;
            const x = Math.random() * (canvas.width - margin * 2) + margin;
            const y = Math.random() * (canvas.height - margin * 2) + margin;
            extraMice.push({ x, y });
        }
        draw();
    };
}
// Patch draw to render extra mice
const originalDrawExtraMice = draw;
draw = function() {
    originalDrawExtraMice();
    // Draw extra mice
    if (extraMice && extraMice.length > 0) {
        ctx.save();
        ctx.font = `${Math.floor(size * 0.8)}px serif`;
        for (let m of extraMice) {
            ctx.fillText('üê≠', m.x, m.y + size * 0.8);
        }
        ctx.restore();
    }
}

// Add direction and speed to gray cats and bossCat6
function randomDirection() {
    let angle = Math.random() * 2 * Math.PI;
    return { dx: Math.cos(angle), dy: Math.sin(angle) };
}

function moveCatTowardMouse() {
    // If there are dogs, cat runs away from the nearest dog (unless frozen, mouse is transparent, or cat is in angry mode)
    if (dogs.length > 0 && !freezeCatActive && !mouseTransparent && !transparentMouseActive && !cat.runAwayFromMouse) {
        // Find the nearest dog
        let nearestDog = null;
        let minDist = Infinity;
        for (let dog of dogs) {
            let dx = dog.x - cat.x;
            let dy = dog.y - cat.y;
            let dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < minDist) {
                minDist = dist;
                nearestDog = dog;
            }
        }
        if (nearestDog) {
            // Run away from the nearest dog
            let dx = cat.x - nearestDog.x;
            let dy = cat.y - nearestDog.y;
            let dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 1) {
                cat.x += cat.speed * dx / dist;
                cat.y += cat.speed * dy / dist;
            }
            // Clamp cat position to stay within canvas
            cat.x = Math.max(0, Math.min(canvas.width - size, cat.x));
            cat.y = Math.max(0, Math.min(canvas.height - size, cat.y));
            checkCatch();
            checkCheeseEat();
            return;
        }
    }
    // If cat is frozen, do nothing
    if (freezeCatActive) return;
    // If mouse is transparent, do nothing
    if (mouseTransparent || transparentMouseActive) return;
    // If cat is running away from mouse (after cheese), do that logic
    if (cat.runAwayFromMouse) {
        let dx = mouse.x - cat.x;
        let dy = mouse.y - cat.y;
        let dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > 1) {
            cat.x -= cat.speed * dx / dist;
            cat.y -= cat.speed * dy / dist;
        }
    } else {
        // --- Smart pipe navigation logic ---
        // Find closest pipe to cat
        let closestPipeToCat = null;
        let minDistToCat = Infinity;
        for (let i = 0; i < pipes.length; i++) {
            const p = pipes[i];
            const dx = (cat.x + size / 2) - p.x;
            const dy = (cat.y + size / 2) - p.y;
            const dist = dx * dx + dy * dy;
            if (dist < minDistToCat) {
                minDistToCat = dist;
                closestPipeToCat = p;
            }
        }
        // Find closest pipe to mouse
        let closestPipeToMouse = null;
        let minDistToMouse = Infinity;
        for (let i = 0; i < pipes.length; i++) {
            const p = pipes[i];
            const dx = (mouse.x + size / 2) - p.x;
            const dy = (mouse.y + size / 2) - p.y;
            const dist = dx * dx + dy * dy;
            if (dist < minDistToMouse) {
                minDistToMouse = dist;
                closestPipeToMouse = p;
            }
        }
        // Distance if walking directly
        const dxDirect = mouse.x - cat.x;
        const dyDirect = mouse.y - cat.y;
        const distDirect = Math.sqrt(dxDirect * dxDirect + dyDirect * dyDirect);
        // Distance if using pipes (cat to pipe + pipe to mouse)
        const distViaPipe = Math.sqrt(minDistToCat) + Math.sqrt(minDistToMouse);
        // Only use pipe if it is a significant shortcut (e.g., at least 20% shorter)
        if (closestPipeToCat && closestPipeToMouse && distViaPipe + size < distDirect) {
            // Move toward the closest pipe to cat
            let dx = closestPipeToCat.x - (cat.x + size / 2);
            let dy = closestPipeToCat.y - (cat.y + size / 2);
            let dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 1) {
                cat.x += cat.speed * dx / dist;
                cat.y += cat.speed * dy / dist;
            }
        } else {
            // Normal: move toward mouse
            let dx = mouse.x - cat.x;
            let dy = mouse.y - cat.y;
            let dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 1) {
                cat.x += cat.speed * dx / dist;
                cat.y += cat.speed * dy / dist;
            }
        }
    }
    // Clamp cat position to stay within canvas
    cat.x = Math.max(0, Math.min(canvas.width - size, cat.x));
    cat.y = Math.max(0, Math.min(canvas.height - size, cat.y));
    checkCatch();
    checkCheeseEat();
}

function checkCatch() {
    if (Math.abs(cat.x - mouse.x) < size && Math.abs(cat.y - mouse.y) < size) {
        showYamYam = true;
        if (yamYamTimer) clearTimeout(yamYamTimer);
        running = false;
        draw(); // Show '–Ω—è–º-–Ω—è–º' immediately
        yamYamTimer = setTimeout(() => {
            showYamYam = false;
            startGame(); // Restart game after 1 second
        }, 1000);
    }
}

function animateMouseScale(target, duration = 250) {
    if (mouseScaleAnimFrame) cancelAnimationFrame(mouseScaleAnimFrame);
    const start = performance.now();
    const initial = mouseScale;
    const delta = target - initial;
    function step(now) {
        let t = Math.min(1, (now - start) / duration);
        // Ease in-out
        t = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        mouseScale = initial + delta * t;
        draw();
        if ((delta > 0 && mouseScale < target) || (delta < 0 && mouseScale > target)) {
            mouseScaleAnimFrame = requestAnimationFrame(step);
        } else {
            mouseScale = target;
            draw();
        }
    }
    mouseScaleAnimFrame = requestAnimationFrame(step);
}

function triggerAngryCatMode() {
    // Remove mouse transparency if active
    mouseTransparent = false;
    transparentMouseActive = false;
    // Make cat run away from mouse for 3 seconds
    cat.runAwayFromMouse = true;
    animateMouseScale(2, 250); // Grow
    if (mouseTransparentTimer) clearTimeout(mouseTransparentTimer);
    mouseTransparentTimer = setTimeout(() => {
        cat.runAwayFromMouse = false;
        animateMouseScale(1, 250); // Shrink
    }, 3000); // 3 seconds
}

function checkCheeseEat() {
    let ate = false;
    cheeses = cheeses.filter(cheese => {
        const dx = cheese.x - mouse.x;
        const dy = (cheese.y + size * 0.7) - (mouse.y + size);
        if (Math.sqrt(dx * dx + dy * dy) <= size * 0.8) {
            ate = true;
            return false;
        }
        return true;
    });
    if (ate) triggerAngryCatMode();
}

canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    let mx = Math.max(0, Math.min(canvas.width - size, e.clientX - rect.left));
    let my = Math.max(0, Math.min(canvas.height - size, e.clientY - rect.top));
    // Prevent mouse from entering pipes
    let blocked = false;
    for (let i = 0; i < pipes.length; i++) {
        const p = pipes[i];
        if (Math.abs(mx + size / 2 - p.x) < size * 0.7 && Math.abs(my + size / 2 - p.y) < size * 0.7) {
            blocked = true;
            // Push mouse out to nearest edge
            const dx = mx + size / 2 - p.x;
            const dy = my + size / 2 - p.y;
            const angle = Math.atan2(dy, dx);
            mx = p.x + Math.cos(angle) * size * 0.7 - size / 2;
            my = p.y + Math.sin(angle) * size * 0.7 - size / 2;
        }
    }
    mouse.x = Math.max(0, Math.min(canvas.width - size, mx));
    mouse.y = Math.max(0, Math.min(canvas.height - size, my));
    checkCheeseEat();
    draw();
});

function updateLevelDisplay() {
    document.getElementById('levelDisplay').textContent = `Level: ${level}`;
}

function startBossCatAddingMinions() {
    if (bossCatAddTimer) clearTimeout(bossCatAddTimer);
    function addMinion() {
        if (level !== 10 || !bossGrayCat) return;
        bossCatMinionCats.push({
            x: Math.floor(Math.random() * (canvas.width - size)),
            y: Math.floor(Math.random() * (canvas.height - size))
        });
        // Schedule next minion at a random interval between 1 and 3 seconds
        bossCatAddTimer = setTimeout(addMinion, 1000 + Math.random() * 2000);
    }
    addMinion();
}

function stopBossCatAddingMinions() {
    if (bossCatAddTimer) clearTimeout(bossCatAddTimer);
    bossCatAddTimer = null;
}

function startCheeseTimer() {
    if (cheeseTimer) clearInterval(cheeseTimer);
    cheeseTimer = setInterval(() => {
        addRandomCheese();
        draw();
    }, 10000);
}

function stopCheeseTimer() {
    if (cheeseTimer) clearInterval(cheeseTimer);
    cheeseTimer = null;
}

function addRandomCheese() {
    // Place cheese at a random position, not overlapping the edges
    if (cheeses.length >= maxCheeseCount) return;
    const margin = size;
    const x = Math.random() * (canvas.width - margin * 2) + margin;
    const y = Math.random() * (canvas.height - margin * 2) + margin;
    cheeses.push({ x, y });
}

function startLevelTimer() {
    if (levelTimer) clearInterval(levelTimer);
    levelTimer = setInterval(() => {
        if (!running) return;
        // Remove dogs that have been present for 2 or more levels
        dogs = dogs.filter(dog => (level - dog.bornLevel) < 2);
        if (level === 6) {
            setTimeout(() => {
                if (level === 6 && running) {
                    level++;
                    cat.speed = +(baseSpeed * Math.pow(1.2, level - 1)).toFixed(2);
                    updateLevelDisplay();
                }
            }, 10000);
            return;
        }
        level++;
        cat.speed = +(baseSpeed * Math.pow(1.2, level - 1)).toFixed(2);
        updateLevelDisplay();
        if (level === 6) {
            // Add 9 gray cats at random positions
            grayCats = [];
            for (let i = 0; i < 9; i++) {
                grayCats.push({
                    x: Math.floor(Math.random() * (canvas.width - size)),
                    y: Math.floor(Math.random() * (canvas.height - size))
                });
            }
            // Add boss cat (5x size)
            bossCat6 = {
                x: Math.floor(Math.random() * (canvas.width - size * 5)),
                y: Math.floor(Math.random() * (canvas.height - size * 5))
            };
            running = false;
            showBossLevel6 = true;
            draw();
            if (bossLevel6Timer) clearTimeout(bossLevel6Timer);
            bossLevel6Timer = setTimeout(() => {
                showBossLevel6 = false;
                running = true;
                draw();
                gameLoop();
            }, 2000);
            return;
        }
        if (level === 10) {
            // Add 1 big gray cat at random position
            bossGrayCat = {
                x: Math.floor(Math.random() * (canvas.width - 180)),
                y: Math.floor(Math.random() * (canvas.height - 180))
            };
            bossCatMinionCats = [];
            running = false;
            showBossLevel = true;
            draw();
            if (bossLevelTimer) clearTimeout(bossLevelTimer);
            bossLevelTimer = setTimeout(() => {
                showBossLevel = false;
                running = true;
                resetGame(10); // Start at level 10
                startBossCatAddingMinions();
                startLevelTimer();
                gameLoop();
            }, 2000);
        }
    }, levelTime * 1000);
}

function resetGame(startLvl) {
    level = startLvl || 1;
    cat.x = 230;
    cat.y = 230;
    cat.speed = baseSpeed;
    updateLevelDisplay();
    if (level === 6) {
        // Add 9 gray cats at random positions
        grayCats = [];
        for (let i = 0; i < 9; i++) {
            grayCats.push({
                x: Math.floor(Math.random() * (canvas.width - size)),
                y: Math.floor(Math.random() * (canvas.height - size))
            });
        }
        // Add boss cat (5x size)
        bossCat6 = {
            x: Math.floor(Math.random() * (canvas.width - size * 5)),
            y: Math.floor(Math.random() * (canvas.height - size * 5))
        };
    } else {
        grayCats = [];
        bossCat6 = null;
    }
    if (level !== 10) {
        bossGrayCat = null;
        bossCatMinionCats = [];
        stopBossCatAddingMinions();
    }
    // Clear bossCat6 if not level 6-9
    if (level < 6 || level >= 10) {
        bossCat6 = null;
    }
    for (let gcat of grayCats) { delete gcat.dx; delete gcat.dy; }
    if (bossCat6) { delete bossCat6.dx; delete bossCat6.dy; }
    // In resetGame, also clear shake effect
    canvas.style.transform = '';
    isShaking = false;
    cheeses = [];
    mouseScale = 1;
}

function startGame() {
    if (!running) {
        running = true;
        resetGame(level === 10 ? 10 : 1);
        startLevelTimer();
        startCheeseTimer();
        gameLoop();
    }
}

document.getElementById('startBtn').onclick = startGame;
document.getElementById('stopBtn').onclick = function() {
    running = false;
    if (levelTimer) clearInterval(levelTimer);
    stopCheeseTimer();
};

function moveEverything() {
    // Move gray cats
    for (let gcat of grayCats) {
        if (!gcat.dx) {
            let d = randomDirection();
            gcat.dx = d.dx * 2; gcat.dy = d.dy * 2;
        }
        gcat.x += gcat.dx;
        gcat.y += gcat.dy;
        if (gcat.x < 0 || gcat.x > canvas.width - size) gcat.dx *= -1;
        if (gcat.y < 0 || gcat.y > canvas.height - size) gcat.dy *= -1;
        gcat.x = Math.max(0, Math.min(canvas.width - size, gcat.x));
        gcat.y = Math.max(0, Math.min(canvas.height - size, gcat.y));
    }
    // Move bossCat6
    if (bossCat6) {
        if (!bossCat6.dx) {
            let d = randomDirection();
            bossCat6.dx = d.dx * 1.5; bossCat6.dy = d.dy * 1.5;
        }
        bossCat6.x += bossCat6.dx;
        bossCat6.y += bossCat6.dy;
        if (bossCat6.x < 0 || bossCat6.x > canvas.width - size * 5) bossCat6.dx *= -1;
        if (bossCat6.y < 0 || bossCat6.y > canvas.height - size * 5) bossCat6.dy *= -1;
        bossCat6.x = Math.max(0, Math.min(canvas.width - size * 5, bossCat6.x));
        bossCat6.y = Math.max(0, Math.min(canvas.height - size * 5, bossCat6.y));
    }
    // Move dogs
    for (let dog of dogs) {
        dog.x += dog.dx;
        dog.y += dog.dy;
        // Bounce off edges
        if (dog.x < 0 || dog.x > canvas.width - size) dog.dx *= -1;
        if (dog.y < 0 || dog.y > canvas.height - size) dog.dy *= -1;
        dog.x = Math.max(0, Math.min(canvas.width - size, dog.x));
        dog.y = Math.max(0, Math.min(canvas.height - size, dog.y));
    }
}

function gameLoop() {
    if (!running) return;
    if (level === 10) {
        // Only move dogs
        for (let dog of dogs) {
            dog.x += dog.dx;
            dog.y += dog.dy;
            if (dog.x < 0 || dog.x > canvas.width - size) dog.dx *= -1;
            if (dog.y < 0 || dog.y > canvas.height - size) dog.dy *= -1;
            dog.x = Math.max(0, Math.min(canvas.width - size, dog.x));
            dog.y = Math.max(0, Math.min(canvas.height - size, dog.y));
        }
        draw();
        requestAnimationFrame(gameLoop);
        return;
    }
    if (level >= 6 && level < 10) moveEverything();
    moveCatTowardMouse();
    checkCatPipeTeleport();
    draw();
    requestAnimationFrame(gameLoop);
}

// Expandable button logic (Bottom Left)
const expandBtn = document.getElementById('expandBtn');
const expandPanel = document.getElementById('expandPanel');
let panelOpen = false;
expandBtn.onclick = function() {
    panelOpen = !panelOpen;
    expandPanel.classList.toggle('open', panelOpen);
};
// Optional: click outside to close
window.addEventListener('mousedown', function(e) {
    if (panelOpen && !expandPanel.contains(e.target) && !expandBtn.contains(e.target)) {
        panelOpen = false;
        expandPanel.classList.remove('open');
    }
});
// Expandable button logic (Bottom Right)
const expandBtnBR = document.getElementById('expandBtnBR');
const expandPanelBR = document.getElementById('expandPanelBR');
let panelOpenBR = false;
expandBtnBR.onclick = function() {
    panelOpenBR = !panelOpenBR;
    expandPanelBR.classList.toggle('open', panelOpenBR);
    if (panelOpenBR) {
        expandPanelBR.style.opacity = '1';
        expandPanelBR.style.pointerEvents = 'auto';
        expandPanelBR.style.transform = 'translateY(0) scale(1)';
        // Pause the game when superpower panel is opened
        if (running) {
            window._wasRunningBeforeSuperpowerPanel = true;
            running = false;
        } else {
            window._wasRunningBeforeSuperpowerPanel = false;
        }
    } else {
        expandPanelBR.style.opacity = '0';
        expandPanelBR.style.pointerEvents = 'none';
        expandPanelBR.style.transform = 'translateY(20px) scale(0.98)';
        // Resume the game if it was running before
        if (window._wasRunningBeforeSuperpowerPanel) {
            running = true;
            gameLoop();
        }
    }
};
window.addEventListener('mousedown', function(e) {
    if (panelOpenBR && !expandPanelBR.contains(e.target) && !expandBtnBR.contains(e.target)) {
        panelOpenBR = false;
        expandPanelBR.classList.remove('open');
        expandPanelBR.style.opacity = '0';
        expandPanelBR.style.pointerEvents = 'none';
        expandPanelBR.style.transform = 'translateY(20px) scale(0.98)';
        // Resume the game if it was running before
        if (window._wasRunningBeforeSuperpowerPanel) {
            running = true;
            gameLoop();
        }
    }
});

// Cat speed slider logic
const catSpeedSlider = document.getElementById('catSpeedSlider');
const catSpeedValue = document.getElementById('catSpeedValue');
if (catSpeedSlider && catSpeedValue) {
    catSpeedSlider.value = baseSpeed;
    catSpeedValue.textContent = baseSpeed;
    catSpeedSlider.addEventListener('input', function() {
        baseSpeed = parseFloat(this.value);
        cat.speed = baseSpeed;
        catSpeedValue.textContent = this.value;
    });
}
// Background switch logic
const bgSwitch = document.getElementById('bgSwitch');
if (bgSwitch) {
    bgSwitch.checked = true;
    bgSwitch.addEventListener('change', function() {
        showWoodenFloor = this.checked;
        draw();
    });
}
// Level time input logic
const levelTimeInput = document.getElementById('levelTimeInput');
if (levelTimeInput) {
    levelTimeInput.value = levelTime;
    levelTimeInput.addEventListener('input', function() {
        let val = parseInt(this.value, 10);
        if (!isNaN(val) && val >= 3 && val <= 60) {
            levelTime = val;
        } else if (val < 3) {
            levelTime = 3;
            this.value = 3;
        }
    });
}
// Cheese count input logic
const cheeseCountInput = document.getElementById('cheeseCountInput');
if (cheeseCountInput) {
    cheeseCountInput.value = maxCheeseCount;
    cheeseCountInput.addEventListener('input', function() {
        let val = parseInt(this.value, 10);
        if (!isNaN(val) && val >= 1 && val <= 10) {
            maxCheeseCount = val;
        } else if (val < 1) {
            maxCheeseCount = 1;
            this.value = 1;
        }
    });
}
// Pipe count input logic
const pipeCountInput = document.getElementById('pipeCountInput');
if (pipeCountInput) {
    pipeCountInput.value = pipeCount;
    pipeCountInput.addEventListener('input', function() {
        let val = parseInt(this.value, 10);
        if (!isNaN(val) && val >= 4 && val <= 10 && val % 2 === 0) {
            pipeCount = val;
        } else if (val < 4) {
            pipeCount = 4;
            this.value = 4;
        } else if (val > 10) {
            pipeCount = 10;
            this.value = 10;
        } else if (val % 2 !== 0) {
            pipeCount = val + 1;
            this.value = pipeCount;
        }
        setupPipes();
        draw();
    });
}

// Superpower panel logic (single block, no duplicates)
let freezeCatTimeout = null;
let freezeCatActive = false;
let transparentMouseActive = false;
const freezeCatBtn = document.getElementById('freezeCatBtn');
const freezeCatStatus = document.getElementById('freezeCatStatus');
const transparentMouseBtn = document.getElementById('transparentMouseBtn');
const transparentMouseStatus = document.getElementById('transparentMouseStatus');

if (freezeCatBtn) {
    freezeCatBtn.onclick = function() {
        if (freezeCatActive) return;
        freezeCatActive = true;
        cat.speed = 0;
        freezeCatStatus.textContent = 'Cat frozen!';
        freezeCatBtn.disabled = true;
        freezeCatBtn.style.opacity = '0.6';
        freezeCatTimeout = setTimeout(() => {
            cat.speed = baseSpeed;
            freezeCatActive = false;
            freezeCatStatus.textContent = '';
            freezeCatBtn.disabled = false;
            freezeCatBtn.style.opacity = '1';
        }, 10000);
        // Auto-close superpower panel
        panelOpenBR = false;
        expandPanelBR.classList.remove('open');
        expandPanelBR.style.opacity = '0';
        expandPanelBR.style.pointerEvents = 'none';
        expandPanelBR.style.transform = 'translateY(20px) scale(0.98)';
        // Resume the game if it was running before
        if (window._wasRunningBeforeSuperpowerPanel) {
            running = true;
            gameLoop();
        }
    };
}
if (transparentMouseBtn) {
    transparentMouseBtn.onclick = function() {
        if (transparentMouseActive) return;
        transparentMouseActive = true;
        transparentMouseStatus.textContent = 'Mouse is transparent!';
        transparentMouseBtn.disabled = true;
        transparentMouseBtn.style.opacity = '0.6';
        mouseTransparent = true;
        setTimeout(() => {
            mouseTransparent = false;
            transparentMouseActive = false;
            transparentMouseStatus.textContent = '';
            transparentMouseBtn.disabled = false;
            transparentMouseBtn.style.opacity = '1';
        }, 10000);
        // Auto-close superpower panel
        panelOpenBR = false;
        expandPanelBR.classList.remove('open');
        expandPanelBR.style.opacity = '0';
        expandPanelBR.style.pointerEvents = 'none';
        expandPanelBR.style.transform = 'translateY(20px) scale(0.98)';
        // Resume the game if it was running before
        if (window._wasRunningBeforeSuperpowerPanel) {
            running = true;
            gameLoop();
        }
    };
}
// Patch drawMouseWithBody to support transparency only once
if (!window._patchedDrawMouseWithBody) {
    const originalDrawMouseWithBody = drawMouseWithBody;
    drawMouseWithBody = function(x, y) {
        ctx.save();
        if (mouseTransparent || transparentMouseActive) {
            ctx.globalAlpha = 0.3;
        }
        originalDrawMouseWithBody(x, y);
        ctx.restore();
    };
    window._patchedDrawMouseWithBody = true;
}

// --- Pipe logic ---
function randomPipePositions(count) {
    const margin = size * 2;
    const positions = [];
    for (let i = 0; i < count; i++) {
        let x, y, tries = 0;
        do {
            x = Math.random() * (canvas.width - margin * 2) + margin;
            y = Math.random() * (canvas.height - margin * 2) + margin;
            tries++;
        } while (positions.some(p => Math.abs(p.x - x) < size * 2 && Math.abs(p.y - y) < size * 2) && tries < 20);
        positions.push({ x, y });
    }
    return positions;
}

function setupPipes() {
    if (pipeCount < 4) pipeCount = 4;
    if (pipeCount % 2 !== 0) pipeCount++;
    pipes = [];
    const positions = randomPipePositions(pipeCount);
    for (let i = 0; i < pipeCount; i += 2) {
        pipes.push({ x: positions[i].x, y: positions[i].y, pair: i + 1 });
        pipes.push({ x: positions[i + 1].x, y: positions[i + 1].y, pair: i });
    }
}

// Draw pipes on canvas
const originalDraw2 = draw;
draw = function() {
    originalDraw2();
    // Draw pipes
    ctx.save();
    for (let i = 0; i < pipes.length; i++) {
        const p = pipes[i];
        ctx.beginPath();
        ctx.arc(p.x, p.y, size * 0.6, 0, 2 * Math.PI);
        ctx.fillStyle = '#1976d2';
        ctx.globalAlpha = 0.7;
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#0d47a1';
        ctx.stroke();
        ctx.font = 'bold 1em sans-serif';
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.fillText(String.fromCharCode(65 + (i % 26)), p.x, p.y + 5);
    }
    ctx.restore();
}

// Cat teleportation logic
let catPipeCooldownUntil = 0; // Timestamp until which cat cannot teleport
function checkCatPipeTeleport() {
    const now = Date.now();
    if (now < catPipeCooldownUntil) return; // Cooldown active
    for (let i = 0; i < pipes.length; i++) {
        const p = pipes[i];
        if (Math.abs(cat.x + size / 2 - p.x) < size * 0.7 && Math.abs(cat.y + size / 2 - p.y) < size * 0.7) {
            // Find the pipe closest to the mouse (excluding the entry pipe)
            let minDist = Infinity;
            let closestPipe = null;
            for (let j = 0; j < pipes.length; j++) {
                if (j === i) continue;
                const candidate = pipes[j];
                const dx = candidate.x - (mouse.x + size / 2);
                const dy = candidate.y - (mouse.y + size / 2);
                const dist = dx * dx + dy * dy;
                if (dist < minDist) {
                    minDist = dist;
                    closestPipe = candidate;
                }
            }
            if (closestPipe) {
                // Calculate direction from entry to exit
                const dx = closestPipe.x - p.x;
                const dy = closestPipe.y - p.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                // Place cat just outside the exit pipe in the direction of travel
                cat.x = closestPipe.x + (dx / dist) * (size * 0.8) - size / 2;
                cat.y = closestPipe.y + (dy / dist) * (size * 0.8) - size / 2;
                catPipeCooldownUntil = Date.now() + 2000; // 2 seconds cooldown
                break;
            }
        }
    }
}
// Patch gameLoop to skip all logic except dogs movement and cheese for level 10
const originalGameLoop2 = gameLoop;
gameLoop = function() {
    if (!running) return;
    if (level === 10) {
        // Only move dogs
        for (let dog of dogs) {
            dog.x += dog.dx;
            dog.y += dog.dy;
            if (dog.x < 0 || dog.x > canvas.width - size) dog.dx *= -1;
            if (dog.y < 0 || dog.y > canvas.height - size) dog.dy *= -1;
            dog.x = Math.max(0, Math.min(canvas.width - size, dog.x));
            dog.y = Math.max(0, Math.min(canvas.height - size, dog.y));
        }
        draw();
        requestAnimationFrame(gameLoop);
        return;
    }
    if (level >= 6 && level < 10) moveEverything();
    moveCatTowardMouse();
    checkCatPipeTeleport();
    draw();
    requestAnimationFrame(gameLoop);
}
// Reset pipes on game reset
const originalResetGame2 = resetGame;
resetGame = function(startLvl) {
    originalResetGame2(startLvl);
    if (level === 10) {
        // Remove all except cheese and dogs
        cat.x = -1000; cat.y = -1000;
        mouse.x = -1000; mouse.y = -1000;
        grayCats = [];
        bossGrayCat = null;
        bossCatMinionCats = [];
        bossCat6 = null;
        pipes = [];
        // Remove all superpower effects
        freezeCatActive = false;
        transparentMouseActive = false;
        mouseTransparent = false;
        showYamYam = false;
        showBossLevel = false;
        showBossLevel6 = false;
        isShaking = false;
    }
}

// Initialize pipes on first load
setupPipes();

draw();
updateLevelDisplay();
</script>
</body>
</html>
